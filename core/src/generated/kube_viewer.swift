// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(kube_viewerFFI)
import kube_viewerFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_kube_viewer_6949_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_kube_viewer_6949_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: {
        $0.deallocate()
        return UniffiInternalError.unexpectedRustCallError
    })
}

private func rustCallWithError<T, F: FfiConverter>
    (_ errorFfiConverter: F.Type, _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T
    where F.SwiftType: Error, F.FfiType == RustBuffer
    {
    try makeRustCall(callback, errorHandler: { return try errorFfiConverter.lift($0) })
}

private func makeRustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T, errorHandler: (RustBuffer) throws -> Error) throws -> T {
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    switch callStatus.code {
        case CALL_SUCCESS:
            return returnedVal

        case CALL_ERROR:
            throw try errorHandler(callStatus.errorBuf)

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}


public protocol FocusRegionHasherProtocol {
    func `hash`(`value`: FocusRegion)  -> UInt64
    
}

public class FocusRegionHasher: FocusRegionHasherProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try!
    
    rustCall() {
    
    kube_viewer_6949_FocusRegionHasher_new($0)
})
    }

    deinit {
        try! rustCall { ffi_kube_viewer_6949_FocusRegionHasher_object_free(pointer, $0) }
    }

    

    
    public func `hash`(`value`: FocusRegion)  -> UInt64 {
        return try! FfiConverterUInt64.lift(
            try!
    rustCall() {
    
    _uniffi_kube_viewer_impl_FocusRegionHasher_hash_32a5(self.pointer, 
        FfiConverterTypeFocusRegion.lower(`value`), $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeFocusRegionHasher: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FocusRegionHasher

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FocusRegionHasher {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FocusRegionHasher, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FocusRegionHasher {
        return FocusRegionHasher(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FocusRegionHasher) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol RustGlobalViewModelProtocol {
    func `addCallbackListener`(`responder`: GlobalViewModelCallback) 
    func `clusters`()  -> [ClusterId: Cluster]
    func `loadClient`(`clusterId`: ClusterId) 
    
}

public class RustGlobalViewModel: RustGlobalViewModelProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try!
    
    rustCall() {
    
    kube_viewer_6949_RustGlobalViewModel_new($0)
})
    }

    deinit {
        try! rustCall { ffi_kube_viewer_6949_RustGlobalViewModel_object_free(pointer, $0) }
    }

    

    
    public func `addCallbackListener`(`responder`: GlobalViewModelCallback)  {
        try!
    rustCall() {
    
    kube_viewer_6949_RustGlobalViewModel_add_callback_listener(self.pointer, 
        FfiConverterCallbackInterfaceGlobalViewModelCallback.lower(`responder`), $0
    )
}
    }
    public func `clusters`()  -> [ClusterId: Cluster] {
        return try! FfiConverterDictionaryTypeClusterIdTypeCluster.lift(
            try!
    rustCall() {
    
    _uniffi_kube_viewer_impl_RustGlobalViewModel_clusters_1daf(self.pointer, $0
    )
}
        )
    }
    public func `loadClient`(`clusterId`: ClusterId)  {
        try!
    rustCall() {
    
    _uniffi_kube_viewer_impl_RustGlobalViewModel_load_client_8507(self.pointer, 
        FfiConverterTypeClusterId.lower(`clusterId`), $0
    )
}
    }
    
}


public struct FfiConverterTypeRustGlobalViewModel: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RustGlobalViewModel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustGlobalViewModel {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RustGlobalViewModel, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RustGlobalViewModel {
        return RustGlobalViewModel(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RustGlobalViewModel) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol RustMainViewModelProtocol {
    func `addUpdateListener`(`listener`: MainViewModelUpdater) 
    func `currentFocusRegion`()  -> FocusRegion
    func `handleKeyInput`(`keyInput`: KeyAwareEvent)  -> Bool
    func `selectedCluster`()  -> Cluster?
    func `selectedTab`()  -> TabId
    func `setCurrentFocusRegion`(`currentFocusRegion`: FocusRegion) 
    func `setSelectedCluster`(`cluster`: Cluster) 
    func `setSelectedTab`(`selectedTab`: TabId) 
    func `setTabGroupExpansions`(`tabGroupExpansions`: [TabGroupId: Bool]) 
    func `setWindowClosed`() 
    func `tabGroupExpansions`()  -> [TabGroupId: Bool]
    func `tabGroups`()  -> [TabGroup]
    func `tabGroupsFiltered`(`search`: String)  -> [TabGroup]
    func `tabs`()  -> [Tab]
    func `tabsMap`()  -> [TabId: Tab]
    
}

public class RustMainViewModel: RustMainViewModelProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`windowId`: String)  {
        self.init(unsafeFromRawPointer: try!
    
    rustCall() {
    
    kube_viewer_6949_RustMainViewModel_new(
        FfiConverterString.lower(`windowId`), $0)
})
    }

    deinit {
        try! rustCall { ffi_kube_viewer_6949_RustMainViewModel_object_free(pointer, $0) }
    }

    

    
    public func `addUpdateListener`(`listener`: MainViewModelUpdater)  {
        try!
    rustCall() {
    
    kube_viewer_6949_RustMainViewModel_add_update_listener(self.pointer, 
        FfiConverterCallbackInterfaceMainViewModelUpdater.lower(`listener`), $0
    )
}
    }
    public func `currentFocusRegion`()  -> FocusRegion {
        return try! FfiConverterTypeFocusRegion.lift(
            try!
    rustCall() {
    
    _uniffi_kube_viewer_impl_RustMainViewModel_current_focus_region_447f(self.pointer, $0
    )
}
        )
    }
    public func `handleKeyInput`(`keyInput`: KeyAwareEvent)  -> Bool {
        return try! FfiConverterBool.lift(
            try!
    rustCall() {
    
    _uniffi_kube_viewer_impl_RustMainViewModel_handle_key_input_81e8(self.pointer, 
        FfiConverterTypeKeyAwareEvent.lower(`keyInput`), $0
    )
}
        )
    }
    public func `selectedCluster`()  -> Cluster? {
        return try! FfiConverterOptionTypeCluster.lift(
            try!
    rustCall() {
    
    _uniffi_kube_viewer_impl_RustMainViewModel_selected_cluster_ebc2(self.pointer, $0
    )
}
        )
    }
    public func `selectedTab`()  -> TabId {
        return try! FfiConverterTypeTabId.lift(
            try!
    rustCall() {
    
    _uniffi_kube_viewer_impl_RustMainViewModel_selected_tab_9ae(self.pointer, $0
    )
}
        )
    }
    public func `setCurrentFocusRegion`(`currentFocusRegion`: FocusRegion)  {
        try!
    rustCall() {
    
    _uniffi_kube_viewer_impl_RustMainViewModel_set_current_focus_region_46b(self.pointer, 
        FfiConverterTypeFocusRegion.lower(`currentFocusRegion`), $0
    )
}
    }
    public func `setSelectedCluster`(`cluster`: Cluster)  {
        try!
    rustCall() {
    
    _uniffi_kube_viewer_impl_RustMainViewModel_set_selected_cluster_8a11(self.pointer, 
        FfiConverterTypeCluster.lower(`cluster`), $0
    )
}
    }
    public func `setSelectedTab`(`selectedTab`: TabId)  {
        try!
    rustCall() {
    
    _uniffi_kube_viewer_impl_RustMainViewModel_set_selected_tab_48a9(self.pointer, 
        FfiConverterTypeTabId.lower(`selectedTab`), $0
    )
}
    }
    public func `setTabGroupExpansions`(`tabGroupExpansions`: [TabGroupId: Bool])  {
        try!
    rustCall() {
    
    _uniffi_kube_viewer_impl_RustMainViewModel_set_tab_group_expansions_ac8c(self.pointer, 
        FfiConverterDictionaryTypeTabGroupIdBool.lower(`tabGroupExpansions`), $0
    )
}
    }
    public func `setWindowClosed`()  {
        try!
    rustCall() {
    
    _uniffi_kube_viewer_impl_RustMainViewModel_set_window_closed_f1bc(self.pointer, $0
    )
}
    }
    public func `tabGroupExpansions`()  -> [TabGroupId: Bool] {
        return try! FfiConverterDictionaryTypeTabGroupIdBool.lift(
            try!
    rustCall() {
    
    _uniffi_kube_viewer_impl_RustMainViewModel_tab_group_expansions_8bbf(self.pointer, $0
    )
}
        )
    }
    public func `tabGroups`()  -> [TabGroup] {
        return try! FfiConverterSequenceTypeTabGroup.lift(
            try!
    rustCall() {
    
    _uniffi_kube_viewer_impl_RustMainViewModel_tab_groups_f31a(self.pointer, $0
    )
}
        )
    }
    public func `tabGroupsFiltered`(`search`: String)  -> [TabGroup] {
        return try! FfiConverterSequenceTypeTabGroup.lift(
            try!
    rustCall() {
    
    _uniffi_kube_viewer_impl_RustMainViewModel_tab_groups_filtered_4d4b(self.pointer, 
        FfiConverterString.lower(`search`), $0
    )
}
        )
    }
    public func `tabs`()  -> [Tab] {
        return try! FfiConverterSequenceTypeTab.lift(
            try!
    rustCall() {
    
    _uniffi_kube_viewer_impl_RustMainViewModel_tabs_57ab(self.pointer, $0
    )
}
        )
    }
    public func `tabsMap`()  -> [TabId: Tab] {
        return try! FfiConverterDictionaryTypeTabIdTypeTab.lift(
            try!
    rustCall() {
    
    _uniffi_kube_viewer_impl_RustMainViewModel_tabs_map_4669(self.pointer, $0
    )
}
        )
    }
    
}


public struct FfiConverterTypeRustMainViewModel: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RustMainViewModel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustMainViewModel {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RustMainViewModel, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RustMainViewModel {
        return RustMainViewModel(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RustMainViewModel) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public protocol RustNodeViewModelProtocol {
    func `addCallbackListener`(`responder`: NodeViewModelCallback) 
    func `fetchNodes`(`selectedCluster`: ClusterId) 
    func `nodes`(`selectedCluster`: ClusterId)  -> [Node]
    func `refreshNodes`(`selectedCluster`: ClusterId) 
    func `stopWatcher`() 
    
}

public class RustNodeViewModel: RustNodeViewModelProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`windowId`: String)  {
        self.init(unsafeFromRawPointer: try!
    
    rustCall() {
    
    kube_viewer_6949_RustNodeViewModel_new(
        FfiConverterString.lower(`windowId`), $0)
})
    }

    deinit {
        try! rustCall { ffi_kube_viewer_6949_RustNodeViewModel_object_free(pointer, $0) }
    }

    
    public static func `preview`(`windowId`: String)  -> RustNodeViewModel {
        return RustNodeViewModel(unsafeFromRawPointer: try!
    
    rustCall() {
    
    kube_viewer_6949_RustNodeViewModel_preview(
        FfiConverterString.lower(`windowId`), $0)
})
    }
    

    
    public func `addCallbackListener`(`responder`: NodeViewModelCallback)  {
        try!
    rustCall() {
    
    kube_viewer_6949_RustNodeViewModel_add_callback_listener(self.pointer, 
        FfiConverterCallbackInterfaceNodeViewModelCallback.lower(`responder`), $0
    )
}
    }
    public func `fetchNodes`(`selectedCluster`: ClusterId)  {
        try!
    rustCall() {
    
    _uniffi_kube_viewer_impl_RustNodeViewModel_fetch_nodes_37d1(self.pointer, 
        FfiConverterTypeClusterId.lower(`selectedCluster`), $0
    )
}
    }
    public func `nodes`(`selectedCluster`: ClusterId)  -> [Node] {
        return try! FfiConverterSequenceTypeNode.lift(
            try!
    rustCall() {
    
    _uniffi_kube_viewer_impl_RustNodeViewModel_nodes_ee8e(self.pointer, 
        FfiConverterTypeClusterId.lower(`selectedCluster`), $0
    )
}
        )
    }
    public func `refreshNodes`(`selectedCluster`: ClusterId)  {
        try!
    rustCall() {
    
    _uniffi_kube_viewer_impl_RustNodeViewModel_refresh_nodes_3509(self.pointer, 
        FfiConverterTypeClusterId.lower(`selectedCluster`), $0
    )
}
    }
    public func `stopWatcher`()  {
        try!
    rustCall() {
    
    _uniffi_kube_viewer_impl_RustNodeViewModel_stop_watcher_6919(self.pointer, $0
    )
}
    }
    
}


public struct FfiConverterTypeRustNodeViewModel: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RustNodeViewModel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustNodeViewModel {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RustNodeViewModel, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RustNodeViewModel {
        return RustNodeViewModel(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RustNodeViewModel) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public struct Cluster {
    public var `id`: ClusterId
    public var `server`: String?
    public var `proxyUrl`: String?
    public var `nickname`: String?
    public var `loadStatus`: LoadStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: ClusterId, `server`: String?, `proxyUrl`: String?, `nickname`: String?, `loadStatus`: LoadStatus) {
        self.`id` = `id`
        self.`server` = `server`
        self.`proxyUrl` = `proxyUrl`
        self.`nickname` = `nickname`
        self.`loadStatus` = `loadStatus`
    }
}


extension Cluster: Equatable, Hashable {
    public static func ==(lhs: Cluster, rhs: Cluster) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`server` != rhs.`server` {
            return false
        }
        if lhs.`proxyUrl` != rhs.`proxyUrl` {
            return false
        }
        if lhs.`nickname` != rhs.`nickname` {
            return false
        }
        if lhs.`loadStatus` != rhs.`loadStatus` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`server`)
        hasher.combine(`proxyUrl`)
        hasher.combine(`nickname`)
        hasher.combine(`loadStatus`)
    }
}


public struct FfiConverterTypeCluster: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Cluster {
        return try Cluster(
            `id`: FfiConverterTypeClusterId.read(from: &buf), 
            `server`: FfiConverterOptionString.read(from: &buf), 
            `proxyUrl`: FfiConverterOptionString.read(from: &buf), 
            `nickname`: FfiConverterOptionString.read(from: &buf), 
            `loadStatus`: FfiConverterTypeLoadStatus.read(from: &buf)
        )
    }

    public static func write(_ value: Cluster, into buf: inout [UInt8]) {
        FfiConverterTypeClusterId.write(value.`id`, into: &buf)
        FfiConverterOptionString.write(value.`server`, into: &buf)
        FfiConverterOptionString.write(value.`proxyUrl`, into: &buf)
        FfiConverterOptionString.write(value.`nickname`, into: &buf)
        FfiConverterTypeLoadStatus.write(value.`loadStatus`, into: &buf)
    }
}


public func FfiConverterTypeCluster_lift(_ buf: RustBuffer) throws -> Cluster {
    return try FfiConverterTypeCluster.lift(buf)
}

public func FfiConverterTypeCluster_lower(_ value: Cluster) -> RustBuffer {
    return FfiConverterTypeCluster.lower(value)
}


public struct ClusterId {
    public var `rawValue`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`rawValue`: String) {
        self.`rawValue` = `rawValue`
    }
}


extension ClusterId: Equatable, Hashable {
    public static func ==(lhs: ClusterId, rhs: ClusterId) -> Bool {
        if lhs.`rawValue` != rhs.`rawValue` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`rawValue`)
    }
}


public struct FfiConverterTypeClusterId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClusterId {
        return try ClusterId(
            `rawValue`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ClusterId, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`rawValue`, into: &buf)
    }
}


public func FfiConverterTypeClusterId_lift(_ buf: RustBuffer) throws -> ClusterId {
    return try FfiConverterTypeClusterId.lift(buf)
}

public func FfiConverterTypeClusterId_lower(_ value: ClusterId) -> RustBuffer {
    return FfiConverterTypeClusterId.lower(value)
}


public struct Node {
    public var `id`: NodeId
    public var `name`: String
    public var `createdAt`: Int64?
    public var `labels`: [String: String]
    public var `annotations`: [String: String]
    public var `taints`: [Taint]
    public var `addresses`: [NodeAddress]
    public var `os`: String?
    public var `arch`: String?
    public var `osImage`: String?
    public var `kernelVersion`: String?
    public var `containerRuntime`: String?
    public var `kubeletVersion`: String?
    public var `conditions`: [NodeCondition]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: NodeId, `name`: String, `createdAt`: Int64?, `labels`: [String: String], `annotations`: [String: String], `taints`: [Taint], `addresses`: [NodeAddress], `os`: String?, `arch`: String?, `osImage`: String?, `kernelVersion`: String?, `containerRuntime`: String?, `kubeletVersion`: String?, `conditions`: [NodeCondition]) {
        self.`id` = `id`
        self.`name` = `name`
        self.`createdAt` = `createdAt`
        self.`labels` = `labels`
        self.`annotations` = `annotations`
        self.`taints` = `taints`
        self.`addresses` = `addresses`
        self.`os` = `os`
        self.`arch` = `arch`
        self.`osImage` = `osImage`
        self.`kernelVersion` = `kernelVersion`
        self.`containerRuntime` = `containerRuntime`
        self.`kubeletVersion` = `kubeletVersion`
        self.`conditions` = `conditions`
    }
}


extension Node: Equatable, Hashable {
    public static func ==(lhs: Node, rhs: Node) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`createdAt` != rhs.`createdAt` {
            return false
        }
        if lhs.`labels` != rhs.`labels` {
            return false
        }
        if lhs.`annotations` != rhs.`annotations` {
            return false
        }
        if lhs.`taints` != rhs.`taints` {
            return false
        }
        if lhs.`addresses` != rhs.`addresses` {
            return false
        }
        if lhs.`os` != rhs.`os` {
            return false
        }
        if lhs.`arch` != rhs.`arch` {
            return false
        }
        if lhs.`osImage` != rhs.`osImage` {
            return false
        }
        if lhs.`kernelVersion` != rhs.`kernelVersion` {
            return false
        }
        if lhs.`containerRuntime` != rhs.`containerRuntime` {
            return false
        }
        if lhs.`kubeletVersion` != rhs.`kubeletVersion` {
            return false
        }
        if lhs.`conditions` != rhs.`conditions` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`name`)
        hasher.combine(`createdAt`)
        hasher.combine(`labels`)
        hasher.combine(`annotations`)
        hasher.combine(`taints`)
        hasher.combine(`addresses`)
        hasher.combine(`os`)
        hasher.combine(`arch`)
        hasher.combine(`osImage`)
        hasher.combine(`kernelVersion`)
        hasher.combine(`containerRuntime`)
        hasher.combine(`kubeletVersion`)
        hasher.combine(`conditions`)
    }
}


public struct FfiConverterTypeNode: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Node {
        return try Node(
            `id`: FfiConverterTypeNodeId.read(from: &buf), 
            `name`: FfiConverterString.read(from: &buf), 
            `createdAt`: FfiConverterOptionInt64.read(from: &buf), 
            `labels`: FfiConverterDictionaryStringString.read(from: &buf), 
            `annotations`: FfiConverterDictionaryStringString.read(from: &buf), 
            `taints`: FfiConverterSequenceTypeTaint.read(from: &buf), 
            `addresses`: FfiConverterSequenceTypeNodeAddress.read(from: &buf), 
            `os`: FfiConverterOptionString.read(from: &buf), 
            `arch`: FfiConverterOptionString.read(from: &buf), 
            `osImage`: FfiConverterOptionString.read(from: &buf), 
            `kernelVersion`: FfiConverterOptionString.read(from: &buf), 
            `containerRuntime`: FfiConverterOptionString.read(from: &buf), 
            `kubeletVersion`: FfiConverterOptionString.read(from: &buf), 
            `conditions`: FfiConverterSequenceTypeNodeCondition.read(from: &buf)
        )
    }

    public static func write(_ value: Node, into buf: inout [UInt8]) {
        FfiConverterTypeNodeId.write(value.`id`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterOptionInt64.write(value.`createdAt`, into: &buf)
        FfiConverterDictionaryStringString.write(value.`labels`, into: &buf)
        FfiConverterDictionaryStringString.write(value.`annotations`, into: &buf)
        FfiConverterSequenceTypeTaint.write(value.`taints`, into: &buf)
        FfiConverterSequenceTypeNodeAddress.write(value.`addresses`, into: &buf)
        FfiConverterOptionString.write(value.`os`, into: &buf)
        FfiConverterOptionString.write(value.`arch`, into: &buf)
        FfiConverterOptionString.write(value.`osImage`, into: &buf)
        FfiConverterOptionString.write(value.`kernelVersion`, into: &buf)
        FfiConverterOptionString.write(value.`containerRuntime`, into: &buf)
        FfiConverterOptionString.write(value.`kubeletVersion`, into: &buf)
        FfiConverterSequenceTypeNodeCondition.write(value.`conditions`, into: &buf)
    }
}


public func FfiConverterTypeNode_lift(_ buf: RustBuffer) throws -> Node {
    return try FfiConverterTypeNode.lift(buf)
}

public func FfiConverterTypeNode_lower(_ value: Node) -> RustBuffer {
    return FfiConverterTypeNode.lower(value)
}


public struct NodeAddress {
    public var `address`: String
    public var `nodeType`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`address`: String, `nodeType`: String) {
        self.`address` = `address`
        self.`nodeType` = `nodeType`
    }
}


extension NodeAddress: Equatable, Hashable {
    public static func ==(lhs: NodeAddress, rhs: NodeAddress) -> Bool {
        if lhs.`address` != rhs.`address` {
            return false
        }
        if lhs.`nodeType` != rhs.`nodeType` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`address`)
        hasher.combine(`nodeType`)
    }
}


public struct FfiConverterTypeNodeAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeAddress {
        return try NodeAddress(
            `address`: FfiConverterString.read(from: &buf), 
            `nodeType`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: NodeAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`address`, into: &buf)
        FfiConverterString.write(value.`nodeType`, into: &buf)
    }
}


public func FfiConverterTypeNodeAddress_lift(_ buf: RustBuffer) throws -> NodeAddress {
    return try FfiConverterTypeNodeAddress.lift(buf)
}

public func FfiConverterTypeNodeAddress_lower(_ value: NodeAddress) -> RustBuffer {
    return FfiConverterTypeNodeAddress.lower(value)
}


public struct NodeCondition {
    public var `name`: String
    public var `status`: String
    public var `reason`: String?
    public var `message`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`name`: String, `status`: String, `reason`: String?, `message`: String?) {
        self.`name` = `name`
        self.`status` = `status`
        self.`reason` = `reason`
        self.`message` = `message`
    }
}


extension NodeCondition: Equatable, Hashable {
    public static func ==(lhs: NodeCondition, rhs: NodeCondition) -> Bool {
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`status` != rhs.`status` {
            return false
        }
        if lhs.`reason` != rhs.`reason` {
            return false
        }
        if lhs.`message` != rhs.`message` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`name`)
        hasher.combine(`status`)
        hasher.combine(`reason`)
        hasher.combine(`message`)
    }
}


public struct FfiConverterTypeNodeCondition: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeCondition {
        return try NodeCondition(
            `name`: FfiConverterString.read(from: &buf), 
            `status`: FfiConverterString.read(from: &buf), 
            `reason`: FfiConverterOptionString.read(from: &buf), 
            `message`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: NodeCondition, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterString.write(value.`status`, into: &buf)
        FfiConverterOptionString.write(value.`reason`, into: &buf)
        FfiConverterOptionString.write(value.`message`, into: &buf)
    }
}


public func FfiConverterTypeNodeCondition_lift(_ buf: RustBuffer) throws -> NodeCondition {
    return try FfiConverterTypeNodeCondition.lift(buf)
}

public func FfiConverterTypeNodeCondition_lower(_ value: NodeCondition) -> RustBuffer {
    return FfiConverterTypeNodeCondition.lower(value)
}


public struct NodeId {
    public var `rawValue`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`rawValue`: String) {
        self.`rawValue` = `rawValue`
    }
}


extension NodeId: Equatable, Hashable {
    public static func ==(lhs: NodeId, rhs: NodeId) -> Bool {
        if lhs.`rawValue` != rhs.`rawValue` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`rawValue`)
    }
}


public struct FfiConverterTypeNodeId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeId {
        return try NodeId(
            `rawValue`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: NodeId, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`rawValue`, into: &buf)
    }
}


public func FfiConverterTypeNodeId_lift(_ buf: RustBuffer) throws -> NodeId {
    return try FfiConverterTypeNodeId.lift(buf)
}

public func FfiConverterTypeNodeId_lower(_ value: NodeId) -> RustBuffer {
    return FfiConverterTypeNodeId.lower(value)
}


public struct Tab {
    public var `id`: TabId
    public var `icon`: String
    public var `name`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: TabId, `icon`: String, `name`: String) {
        self.`id` = `id`
        self.`icon` = `icon`
        self.`name` = `name`
    }
}


extension Tab: Equatable, Hashable {
    public static func ==(lhs: Tab, rhs: Tab) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`icon` != rhs.`icon` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`icon`)
        hasher.combine(`name`)
    }
}


public struct FfiConverterTypeTab: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Tab {
        return try Tab(
            `id`: FfiConverterTypeTabId.read(from: &buf), 
            `icon`: FfiConverterString.read(from: &buf), 
            `name`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Tab, into buf: inout [UInt8]) {
        FfiConverterTypeTabId.write(value.`id`, into: &buf)
        FfiConverterString.write(value.`icon`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
    }
}


public func FfiConverterTypeTab_lift(_ buf: RustBuffer) throws -> Tab {
    return try FfiConverterTypeTab.lift(buf)
}

public func FfiConverterTypeTab_lower(_ value: Tab) -> RustBuffer {
    return FfiConverterTypeTab.lower(value)
}


public struct TabGroup {
    public var `id`: TabGroupId
    public var `name`: String
    public var `tabs`: [Tab]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: TabGroupId, `name`: String, `tabs`: [Tab]) {
        self.`id` = `id`
        self.`name` = `name`
        self.`tabs` = `tabs`
    }
}


extension TabGroup: Equatable, Hashable {
    public static func ==(lhs: TabGroup, rhs: TabGroup) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`tabs` != rhs.`tabs` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`name`)
        hasher.combine(`tabs`)
    }
}


public struct FfiConverterTypeTabGroup: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TabGroup {
        return try TabGroup(
            `id`: FfiConverterTypeTabGroupId.read(from: &buf), 
            `name`: FfiConverterString.read(from: &buf), 
            `tabs`: FfiConverterSequenceTypeTab.read(from: &buf)
        )
    }

    public static func write(_ value: TabGroup, into buf: inout [UInt8]) {
        FfiConverterTypeTabGroupId.write(value.`id`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterSequenceTypeTab.write(value.`tabs`, into: &buf)
    }
}


public func FfiConverterTypeTabGroup_lift(_ buf: RustBuffer) throws -> TabGroup {
    return try FfiConverterTypeTabGroup.lift(buf)
}

public func FfiConverterTypeTabGroup_lower(_ value: TabGroup) -> RustBuffer {
    return FfiConverterTypeTabGroup.lower(value)
}


public struct Taint {
    public var `effect`: String
    public var `key`: String
    public var `timeAdded`: String?
    public var `value`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`effect`: String, `key`: String, `timeAdded`: String?, `value`: String?) {
        self.`effect` = `effect`
        self.`key` = `key`
        self.`timeAdded` = `timeAdded`
        self.`value` = `value`
    }
}


extension Taint: Equatable, Hashable {
    public static func ==(lhs: Taint, rhs: Taint) -> Bool {
        if lhs.`effect` != rhs.`effect` {
            return false
        }
        if lhs.`key` != rhs.`key` {
            return false
        }
        if lhs.`timeAdded` != rhs.`timeAdded` {
            return false
        }
        if lhs.`value` != rhs.`value` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`effect`)
        hasher.combine(`key`)
        hasher.combine(`timeAdded`)
        hasher.combine(`value`)
    }
}


public struct FfiConverterTypeTaint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Taint {
        return try Taint(
            `effect`: FfiConverterString.read(from: &buf), 
            `key`: FfiConverterString.read(from: &buf), 
            `timeAdded`: FfiConverterOptionString.read(from: &buf), 
            `value`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Taint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`effect`, into: &buf)
        FfiConverterString.write(value.`key`, into: &buf)
        FfiConverterOptionString.write(value.`timeAdded`, into: &buf)
        FfiConverterOptionString.write(value.`value`, into: &buf)
    }
}


public func FfiConverterTypeTaint_lift(_ buf: RustBuffer) throws -> Taint {
    return try FfiConverterTypeTaint.lift(buf)
}

public func FfiConverterTypeTaint_lower(_ value: Taint) -> RustBuffer {
    return FfiConverterTypeTaint.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum FocusRegion {
    
    case `sidebarSearch`
    case `sidebarGroup`(`id`: TabGroupId)
    case `inTabGroup`(`tabGroupId`: TabGroupId, `tabId`: TabId)
    case `clusterSelection`
    case `content`
}

public struct FfiConverterTypeFocusRegion: FfiConverterRustBuffer {
    typealias SwiftType = FocusRegion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FocusRegion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`sidebarSearch`
        
        case 2: return .`sidebarGroup`(
            `id`: try FfiConverterTypeTabGroupId.read(from: &buf)
        )
        
        case 3: return .`inTabGroup`(
            `tabGroupId`: try FfiConverterTypeTabGroupId.read(from: &buf), 
            `tabId`: try FfiConverterTypeTabId.read(from: &buf)
        )
        
        case 4: return .`clusterSelection`
        
        case 5: return .`content`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FocusRegion, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`sidebarSearch`:
            writeInt(&buf, Int32(1))
        
        
        case let .`sidebarGroup`(`id`):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTabGroupId.write(`id`, into: &buf)
            
        
        case let .`inTabGroup`(`tabGroupId`,`tabId`):
            writeInt(&buf, Int32(3))
            FfiConverterTypeTabGroupId.write(`tabGroupId`, into: &buf)
            FfiConverterTypeTabId.write(`tabId`, into: &buf)
            
        
        case .`clusterSelection`:
            writeInt(&buf, Int32(4))
        
        
        case .`content`:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeFocusRegion_lift(_ buf: RustBuffer) throws -> FocusRegion {
    return try FfiConverterTypeFocusRegion.lift(buf)
}

public func FfiConverterTypeFocusRegion_lower(_ value: FocusRegion) -> RustBuffer {
    return FfiConverterTypeFocusRegion.lower(value)
}


extension FocusRegion: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum GlobalViewModelMessage {
    
    case `clustersLoaded`
    case `loadingClient`
    case `clientLoaded`
    case `clientLoadError`(`error`: String)
}

public struct FfiConverterTypeGlobalViewModelMessage: FfiConverterRustBuffer {
    typealias SwiftType = GlobalViewModelMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalViewModelMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`clustersLoaded`
        
        case 2: return .`loadingClient`
        
        case 3: return .`clientLoaded`
        
        case 4: return .`clientLoadError`(
            `error`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GlobalViewModelMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`clustersLoaded`:
            writeInt(&buf, Int32(1))
        
        
        case .`loadingClient`:
            writeInt(&buf, Int32(2))
        
        
        case .`clientLoaded`:
            writeInt(&buf, Int32(3))
        
        
        case let .`clientLoadError`(`error`):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(`error`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeGlobalViewModelMessage_lift(_ buf: RustBuffer) throws -> GlobalViewModelMessage {
    return try FfiConverterTypeGlobalViewModelMessage.lift(buf)
}

public func FfiConverterTypeGlobalViewModelMessage_lower(_ value: GlobalViewModelMessage) -> RustBuffer {
    return FfiConverterTypeGlobalViewModelMessage.lower(value)
}


extension GlobalViewModelMessage: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum KeyAwareEvent {
    
    case `delete`
    case `upArrow`
    case `downArrow`
    case `leftArrow`
    case `rightArrow`
    case `space`
    case `enter`
    case `shiftTab`
    case `tabKey`
    case `escape`
    case `optionF`
}

public struct FfiConverterTypeKeyAwareEvent: FfiConverterRustBuffer {
    typealias SwiftType = KeyAwareEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyAwareEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`delete`
        
        case 2: return .`upArrow`
        
        case 3: return .`downArrow`
        
        case 4: return .`leftArrow`
        
        case 5: return .`rightArrow`
        
        case 6: return .`space`
        
        case 7: return .`enter`
        
        case 8: return .`shiftTab`
        
        case 9: return .`tabKey`
        
        case 10: return .`escape`
        
        case 11: return .`optionF`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeyAwareEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`delete`:
            writeInt(&buf, Int32(1))
        
        
        case .`upArrow`:
            writeInt(&buf, Int32(2))
        
        
        case .`downArrow`:
            writeInt(&buf, Int32(3))
        
        
        case .`leftArrow`:
            writeInt(&buf, Int32(4))
        
        
        case .`rightArrow`:
            writeInt(&buf, Int32(5))
        
        
        case .`space`:
            writeInt(&buf, Int32(6))
        
        
        case .`enter`:
            writeInt(&buf, Int32(7))
        
        
        case .`shiftTab`:
            writeInt(&buf, Int32(8))
        
        
        case .`tabKey`:
            writeInt(&buf, Int32(9))
        
        
        case .`escape`:
            writeInt(&buf, Int32(10))
        
        
        case .`optionF`:
            writeInt(&buf, Int32(11))
        
        }
    }
}


public func FfiConverterTypeKeyAwareEvent_lift(_ buf: RustBuffer) throws -> KeyAwareEvent {
    return try FfiConverterTypeKeyAwareEvent.lift(buf)
}

public func FfiConverterTypeKeyAwareEvent_lower(_ value: KeyAwareEvent) -> RustBuffer {
    return FfiConverterTypeKeyAwareEvent.lower(value)
}


extension KeyAwareEvent: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LoadStatus {
    
    case `initial`
    case `loading`
    case `loaded`
    case `error`(`error`: String)
}

public struct FfiConverterTypeLoadStatus: FfiConverterRustBuffer {
    typealias SwiftType = LoadStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LoadStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`initial`
        
        case 2: return .`loading`
        
        case 3: return .`loaded`
        
        case 4: return .`error`(
            `error`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LoadStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`initial`:
            writeInt(&buf, Int32(1))
        
        
        case .`loading`:
            writeInt(&buf, Int32(2))
        
        
        case .`loaded`:
            writeInt(&buf, Int32(3))
        
        
        case let .`error`(`error`):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(`error`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeLoadStatus_lift(_ buf: RustBuffer) throws -> LoadStatus {
    return try FfiConverterTypeLoadStatus.lift(buf)
}

public func FfiConverterTypeLoadStatus_lower(_ value: LoadStatus) -> RustBuffer {
    return FfiConverterTypeLoadStatus.lower(value)
}


extension LoadStatus: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MainViewModelField {
    
    case `currentFocusRegion`
    case `selectedTab`
    case `tabGroupExpansions`
}

public struct FfiConverterTypeMainViewModelField: FfiConverterRustBuffer {
    typealias SwiftType = MainViewModelField

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MainViewModelField {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`currentFocusRegion`
        
        case 2: return .`selectedTab`
        
        case 3: return .`tabGroupExpansions`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MainViewModelField, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`currentFocusRegion`:
            writeInt(&buf, Int32(1))
        
        
        case .`selectedTab`:
            writeInt(&buf, Int32(2))
        
        
        case .`tabGroupExpansions`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeMainViewModelField_lift(_ buf: RustBuffer) throws -> MainViewModelField {
    return try FfiConverterTypeMainViewModelField.lift(buf)
}

public func FfiConverterTypeMainViewModelField_lower(_ value: MainViewModelField) -> RustBuffer {
    return FfiConverterTypeMainViewModelField.lower(value)
}


extension MainViewModelField: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum NodeLoadStatus {
    
    case `initial`
    case `loading`
    case `loaded`(`nodes`: [Node])
    case `error`(`error`: String)
}

public struct FfiConverterTypeNodeLoadStatus: FfiConverterRustBuffer {
    typealias SwiftType = NodeLoadStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeLoadStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`initial`
        
        case 2: return .`loading`
        
        case 3: return .`loaded`(
            `nodes`: try FfiConverterSequenceTypeNode.read(from: &buf)
        )
        
        case 4: return .`error`(
            `error`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NodeLoadStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`initial`:
            writeInt(&buf, Int32(1))
        
        
        case .`loading`:
            writeInt(&buf, Int32(2))
        
        
        case let .`loaded`(`nodes`):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeNode.write(`nodes`, into: &buf)
            
        
        case let .`error`(`error`):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(`error`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNodeLoadStatus_lift(_ buf: RustBuffer) throws -> NodeLoadStatus {
    return try FfiConverterTypeNodeLoadStatus.lift(buf)
}

public func FfiConverterTypeNodeLoadStatus_lower(_ value: NodeLoadStatus) -> RustBuffer {
    return FfiConverterTypeNodeLoadStatus.lower(value)
}


extension NodeLoadStatus: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum NodeViewModelMessage {
    
    case `loadingNodes`
    case `nodesLoaded`
    case `nodeLoadingFailed`(`error`: String)
}

public struct FfiConverterTypeNodeViewModelMessage: FfiConverterRustBuffer {
    typealias SwiftType = NodeViewModelMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeViewModelMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`loadingNodes`
        
        case 2: return .`nodesLoaded`
        
        case 3: return .`nodeLoadingFailed`(
            `error`: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NodeViewModelMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`loadingNodes`:
            writeInt(&buf, Int32(1))
        
        
        case .`nodesLoaded`:
            writeInt(&buf, Int32(2))
        
        
        case let .`nodeLoadingFailed`(`error`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`error`, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNodeViewModelMessage_lift(_ buf: RustBuffer) throws -> NodeViewModelMessage {
    return try FfiConverterTypeNodeViewModelMessage.lift(buf)
}

public func FfiConverterTypeNodeViewModelMessage_lower(_ value: NodeViewModelMessage) -> RustBuffer {
    return FfiConverterTypeNodeViewModelMessage.lower(value)
}


extension NodeViewModelMessage: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TabGroupId {
    
    case `general`
    case `workloads`
    case `config`
    case `network`
    case `storage`
    case `accessControl`
    case `helm`
}

public struct FfiConverterTypeTabGroupId: FfiConverterRustBuffer {
    typealias SwiftType = TabGroupId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TabGroupId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`general`
        
        case 2: return .`workloads`
        
        case 3: return .`config`
        
        case 4: return .`network`
        
        case 5: return .`storage`
        
        case 6: return .`accessControl`
        
        case 7: return .`helm`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TabGroupId, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`general`:
            writeInt(&buf, Int32(1))
        
        
        case .`workloads`:
            writeInt(&buf, Int32(2))
        
        
        case .`config`:
            writeInt(&buf, Int32(3))
        
        
        case .`network`:
            writeInt(&buf, Int32(4))
        
        
        case .`storage`:
            writeInt(&buf, Int32(5))
        
        
        case .`accessControl`:
            writeInt(&buf, Int32(6))
        
        
        case .`helm`:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeTabGroupId_lift(_ buf: RustBuffer) throws -> TabGroupId {
    return try FfiConverterTypeTabGroupId.lift(buf)
}

public func FfiConverterTypeTabGroupId_lower(_ value: TabGroupId) -> RustBuffer {
    return FfiConverterTypeTabGroupId.lower(value)
}


extension TabGroupId: Equatable, Hashable {}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TabId {
    
    case `clusterTab`
    case `nodes`
    case `nameSpaces`
    case `events`
    case `overview`
    case `pods`
    case `deployments`
    case `daemonSets`
    case `statefulSets`
    case `replicaSets`
    case `jobs`
    case `cronJobs`
    case `configMaps`
    case `secrets`
    case `resourceQuotas`
    case `limitRanges`
    case `horizontalPodAutoscalers`
    case `podDisruptionBudgets`
    case `priorityClasses`
    case `runtimeClasses`
    case `leases`
    case `services`
    case `endpoints`
    case `ingresses`
    case `networkPolicies`
    case `portForwarding`
    case `persistentVolumeClaims`
    case `persistentVolumes`
    case `storageClasses`
    case `serviceAccounts`
    case `clusterRoles`
    case `roles`
    case `clusterRoleBindings`
    case `roleBindings`
    case `podSecurityPolicies`
    case `charts`
    case `releases`
}

public struct FfiConverterTypeTabId: FfiConverterRustBuffer {
    typealias SwiftType = TabId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TabId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`clusterTab`
        
        case 2: return .`nodes`
        
        case 3: return .`nameSpaces`
        
        case 4: return .`events`
        
        case 5: return .`overview`
        
        case 6: return .`pods`
        
        case 7: return .`deployments`
        
        case 8: return .`daemonSets`
        
        case 9: return .`statefulSets`
        
        case 10: return .`replicaSets`
        
        case 11: return .`jobs`
        
        case 12: return .`cronJobs`
        
        case 13: return .`configMaps`
        
        case 14: return .`secrets`
        
        case 15: return .`resourceQuotas`
        
        case 16: return .`limitRanges`
        
        case 17: return .`horizontalPodAutoscalers`
        
        case 18: return .`podDisruptionBudgets`
        
        case 19: return .`priorityClasses`
        
        case 20: return .`runtimeClasses`
        
        case 21: return .`leases`
        
        case 22: return .`services`
        
        case 23: return .`endpoints`
        
        case 24: return .`ingresses`
        
        case 25: return .`networkPolicies`
        
        case 26: return .`portForwarding`
        
        case 27: return .`persistentVolumeClaims`
        
        case 28: return .`persistentVolumes`
        
        case 29: return .`storageClasses`
        
        case 30: return .`serviceAccounts`
        
        case 31: return .`clusterRoles`
        
        case 32: return .`roles`
        
        case 33: return .`clusterRoleBindings`
        
        case 34: return .`roleBindings`
        
        case 35: return .`podSecurityPolicies`
        
        case 36: return .`charts`
        
        case 37: return .`releases`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TabId, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`clusterTab`:
            writeInt(&buf, Int32(1))
        
        
        case .`nodes`:
            writeInt(&buf, Int32(2))
        
        
        case .`nameSpaces`:
            writeInt(&buf, Int32(3))
        
        
        case .`events`:
            writeInt(&buf, Int32(4))
        
        
        case .`overview`:
            writeInt(&buf, Int32(5))
        
        
        case .`pods`:
            writeInt(&buf, Int32(6))
        
        
        case .`deployments`:
            writeInt(&buf, Int32(7))
        
        
        case .`daemonSets`:
            writeInt(&buf, Int32(8))
        
        
        case .`statefulSets`:
            writeInt(&buf, Int32(9))
        
        
        case .`replicaSets`:
            writeInt(&buf, Int32(10))
        
        
        case .`jobs`:
            writeInt(&buf, Int32(11))
        
        
        case .`cronJobs`:
            writeInt(&buf, Int32(12))
        
        
        case .`configMaps`:
            writeInt(&buf, Int32(13))
        
        
        case .`secrets`:
            writeInt(&buf, Int32(14))
        
        
        case .`resourceQuotas`:
            writeInt(&buf, Int32(15))
        
        
        case .`limitRanges`:
            writeInt(&buf, Int32(16))
        
        
        case .`horizontalPodAutoscalers`:
            writeInt(&buf, Int32(17))
        
        
        case .`podDisruptionBudgets`:
            writeInt(&buf, Int32(18))
        
        
        case .`priorityClasses`:
            writeInt(&buf, Int32(19))
        
        
        case .`runtimeClasses`:
            writeInt(&buf, Int32(20))
        
        
        case .`leases`:
            writeInt(&buf, Int32(21))
        
        
        case .`services`:
            writeInt(&buf, Int32(22))
        
        
        case .`endpoints`:
            writeInt(&buf, Int32(23))
        
        
        case .`ingresses`:
            writeInt(&buf, Int32(24))
        
        
        case .`networkPolicies`:
            writeInt(&buf, Int32(25))
        
        
        case .`portForwarding`:
            writeInt(&buf, Int32(26))
        
        
        case .`persistentVolumeClaims`:
            writeInt(&buf, Int32(27))
        
        
        case .`persistentVolumes`:
            writeInt(&buf, Int32(28))
        
        
        case .`storageClasses`:
            writeInt(&buf, Int32(29))
        
        
        case .`serviceAccounts`:
            writeInt(&buf, Int32(30))
        
        
        case .`clusterRoles`:
            writeInt(&buf, Int32(31))
        
        
        case .`roles`:
            writeInt(&buf, Int32(32))
        
        
        case .`clusterRoleBindings`:
            writeInt(&buf, Int32(33))
        
        
        case .`roleBindings`:
            writeInt(&buf, Int32(34))
        
        
        case .`podSecurityPolicies`:
            writeInt(&buf, Int32(35))
        
        
        case .`charts`:
            writeInt(&buf, Int32(36))
        
        
        case .`releases`:
            writeInt(&buf, Int32(37))
        
        }
    }
}


public func FfiConverterTypeTabId_lift(_ buf: RustBuffer) throws -> TabId {
    return try FfiConverterTypeTabId.lift(buf)
}

public func FfiConverterTypeTabId_lower(_ value: TabId) -> RustBuffer {
    return FfiConverterTypeTabId.lower(value)
}


extension TabId: Equatable, Hashable {}


fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias UniFFICallbackHandle = UInt64
fileprivate class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0

// Declaration and FfiConverters for GlobalViewModelCallback Callback Interface

public protocol GlobalViewModelCallback : AnyObject {
    func `callback`(`msg`: GlobalViewModelMessage) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceGlobalViewModelCallback : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeCallback`(_ swiftCallbackInterface: GlobalViewModelCallback, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            swiftCallbackInterface.`callback`(
                    `msg`:  try FfiConverterTypeGlobalViewModelMessage.read(from: &reader)
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: GlobalViewModelCallback
        do {
            cb = try FfiConverterCallbackInterfaceGlobalViewModelCallback.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("GlobalViewModelCallback: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceGlobalViewModelCallback.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeCallback`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceGlobalViewModelCallback {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_kube_viewer_6949_GlobalViewModelCallback_init_callback(foreignCallbackCallbackInterfaceGlobalViewModelCallback, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<GlobalViewModelCallback>()
}

extension FfiConverterCallbackInterfaceGlobalViewModelCallback : FfiConverter {
    typealias SwiftType = GlobalViewModelCallback
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for MainViewModelUpdater Callback Interface

public protocol MainViewModelUpdater : AnyObject {
    func `update`(`field`: MainViewModelField) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceMainViewModelUpdater : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeUpdate`(_ swiftCallbackInterface: MainViewModelUpdater, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            swiftCallbackInterface.`update`(
                    `field`:  try FfiConverterTypeMainViewModelField.read(from: &reader)
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: MainViewModelUpdater
        do {
            cb = try FfiConverterCallbackInterfaceMainViewModelUpdater.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("MainViewModelUpdater: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceMainViewModelUpdater.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeUpdate`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceMainViewModelUpdater {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_kube_viewer_6949_MainViewModelUpdater_init_callback(foreignCallbackCallbackInterfaceMainViewModelUpdater, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<MainViewModelUpdater>()
}

extension FfiConverterCallbackInterfaceMainViewModelUpdater : FfiConverter {
    typealias SwiftType = MainViewModelUpdater
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for NodeViewModelCallback Callback Interface

public protocol NodeViewModelCallback : AnyObject {
    func `callback`(`msg`: NodeViewModelMessage) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceNodeViewModelCallback : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, args: RustBuffer, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
        func `invokeCallback`(_ swiftCallbackInterface: NodeViewModelCallback, _ args: RustBuffer) throws -> RustBuffer {
        defer { args.deallocate() }

            var reader = createReader(data: Data(rustBuffer: args))
            swiftCallbackInterface.`callback`(
                    `msg`:  try FfiConverterTypeNodeViewModelMessage.read(from: &reader)
                    )
            return RustBuffer()
                // TODO catch errors and report them back to Rust.
                // https://github.com/mozilla/uniffi-rs/issues/351

        }
        

        let cb: NodeViewModelCallback
        do {
            cb = try FfiConverterCallbackInterfaceNodeViewModelCallback.lift(handle)
        } catch {
            out_buf.pointee = FfiConverterString.lower("NodeViewModelCallback: Invalid handle")
            return -1
        }

        switch method {
            case IDX_CALLBACK_FREE:
                FfiConverterCallbackInterfaceNodeViewModelCallback.drop(handle: handle)
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0
            case 1:
                do {
                    out_buf.pointee = try `invokeCallback`(cb, args)
                    // Value written to out buffer.
                    // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                    return 1
                } catch let error {
                    out_buf.pointee = FfiConverterString.lower(String(describing: error))
                    return -1
                }
            
            // This should never happen, because an out of bounds method index won't
            // ever be used. Once we can catch errors, we should return an InternalError.
            // https://github.com/mozilla/uniffi-rs/issues/351
            default:
                // An unexpected error happened.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return -1
        }
    }

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceNodeViewModelCallback {
    // Initialize our callback method with the scaffolding code
    private static var callbackInitialized = false
    private static func initCallback() {
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
                ffi_kube_viewer_6949_NodeViewModelCallback_init_callback(foreignCallbackCallbackInterfaceNodeViewModelCallback, err)
        }
    }
    private static func ensureCallbackinitialized() {
        if !callbackInitialized {
            initCallback()
            callbackInitialized = true
        }
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<NodeViewModelCallback>()
}

extension FfiConverterCallbackInterfaceNodeViewModelCallback : FfiConverter {
    typealias SwiftType = NodeViewModelCallback
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeCluster: FfiConverterRustBuffer {
    typealias SwiftType = Cluster?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCluster.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCluster.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceTypeNode: FfiConverterRustBuffer {
    typealias SwiftType = [Node]

    public static func write(_ value: [Node], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNode.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Node] {
        let len: Int32 = try readInt(&buf)
        var seq = [Node]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNode.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeNodeAddress: FfiConverterRustBuffer {
    typealias SwiftType = [NodeAddress]

    public static func write(_ value: [NodeAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNodeAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NodeAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [NodeAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNodeAddress.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeNodeCondition: FfiConverterRustBuffer {
    typealias SwiftType = [NodeCondition]

    public static func write(_ value: [NodeCondition], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNodeCondition.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NodeCondition] {
        let len: Int32 = try readInt(&buf)
        var seq = [NodeCondition]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNodeCondition.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTab: FfiConverterRustBuffer {
    typealias SwiftType = [Tab]

    public static func write(_ value: [Tab], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTab.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Tab] {
        let len: Int32 = try readInt(&buf)
        var seq = [Tab]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTab.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTabGroup: FfiConverterRustBuffer {
    typealias SwiftType = [TabGroup]

    public static func write(_ value: [TabGroup], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTabGroup.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TabGroup] {
        let len: Int32 = try readInt(&buf)
        var seq = [TabGroup]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTabGroup.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTaint: FfiConverterRustBuffer {
    typealias SwiftType = [Taint]

    public static func write(_ value: [Taint], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTaint.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Taint] {
        let len: Int32 = try readInt(&buf)
        var seq = [Taint]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTaint.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypeClusterIdTypeCluster: FfiConverterRustBuffer {
    public static func write(_ value: [ClusterId: Cluster], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeClusterId.write(key, into: &buf)
            FfiConverterTypeCluster.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ClusterId: Cluster] {
        let len: Int32 = try readInt(&buf)
        var dict = [ClusterId: Cluster]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeClusterId.read(from: &buf)
            let value = try FfiConverterTypeCluster.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypeTabGroupIdBool: FfiConverterRustBuffer {
    public static func write(_ value: [TabGroupId: Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeTabGroupId.write(key, into: &buf)
            FfiConverterBool.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TabGroupId: Bool] {
        let len: Int32 = try readInt(&buf)
        var dict = [TabGroupId: Bool]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeTabGroupId.read(from: &buf)
            let value = try FfiConverterBool.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypeTabIdTypeTab: FfiConverterRustBuffer {
    public static func write(_ value: [TabId: Tab], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeTabId.write(key, into: &buf)
            FfiConverterTypeTab.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TabId: Tab] {
        let len: Int32 = try readInt(&buf)
        var dict = [TabId: Tab]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeTabId.read(from: &buf)
            let value = try FfiConverterTypeTab.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

public func `nodePreview`()  -> Node {
    return try! FfiConverterTypeNode.lift(
        try!
    
    rustCall() {
    
    _uniffi_kube_viewer_node_preview_4d4f($0)
}
    )
}



/**
 * Top level initializers and tear down methods.
 *
 * This is generated by uniffi.
 */
public enum KubeViewerLifecycle {
    /**
     * Initialize the FFI and Rust library. This should be only called once per application.
     */
    func initialize() {
    }
}