// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(kube_viewerFFI)
import kube_viewerFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_kube_viewer_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_kube_viewer_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}


public protocol FocusRegionHasherProtocol {
    func hash(value: FocusRegion)   -> UInt64
    
}

public class FocusRegionHasher: FocusRegionHasherProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_kube_viewer_fn_constructor_focusregionhasher_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_kube_viewer_fn_free_focusregionhasher(pointer, $0) }
    }

    

    
    

    public func hash(value: FocusRegion)  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_kube_viewer_fn_method_focusregionhasher_hash(self.pointer, 
        FfiConverterTypeFocusRegion.lower(value),$0
    )
}
        )
    }
}

public struct FfiConverterTypeFocusRegionHasher: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FocusRegionHasher

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FocusRegionHasher {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FocusRegionHasher, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FocusRegionHasher {
        return FocusRegionHasher(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FocusRegionHasher) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeFocusRegionHasher_lift(_ pointer: UnsafeMutableRawPointer) throws -> FocusRegionHasher {
    return try FfiConverterTypeFocusRegionHasher.lift(pointer)
}

public func FfiConverterTypeFocusRegionHasher_lower(_ value: FocusRegionHasher) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFocusRegionHasher.lower(value)
}


public protocol RustGlobalViewModelProtocol {
    func addCallbackListener(responder: GlobalViewModelCallback) async 
    func clusters()   -> [ClusterId: Cluster]
    func loadClient(clusterId: ClusterId)  
    
}

public class RustGlobalViewModel: RustGlobalViewModelProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_kube_viewer_fn_constructor_rustglobalviewmodel_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_kube_viewer_fn_free_rustglobalviewmodel(pointer, $0) }
    }

    

    
    

    public func addCallbackListener(responder: GlobalViewModelCallback) async  {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try!  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_kube_viewer_fn_method_rustglobalviewmodel_add_callback_listener(
                    self.pointer,
                    
        FfiConverterCallbackInterfaceGlobalViewModelCallback.lower(responder),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoid,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func clusters()  -> [ClusterId: Cluster] {
        return try!  FfiConverterDictionaryTypeClusterIdTypeCluster.lift(
            try! 
    rustCall() {
    
    uniffi_kube_viewer_fn_method_rustglobalviewmodel_clusters(self.pointer, $0
    )
}
        )
    }

    public func loadClient(clusterId: ClusterId)  {
        try! 
    rustCall() {
    
    uniffi_kube_viewer_fn_method_rustglobalviewmodel_load_client(self.pointer, 
        FfiConverterTypeClusterId.lower(clusterId),$0
    )
}
    }
}

public struct FfiConverterTypeRustGlobalViewModel: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RustGlobalViewModel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustGlobalViewModel {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RustGlobalViewModel, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RustGlobalViewModel {
        return RustGlobalViewModel(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RustGlobalViewModel) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeRustGlobalViewModel_lift(_ pointer: UnsafeMutableRawPointer) throws -> RustGlobalViewModel {
    return try FfiConverterTypeRustGlobalViewModel.lift(pointer)
}

public func FfiConverterTypeRustGlobalViewModel_lower(_ value: RustGlobalViewModel) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRustGlobalViewModel.lower(value)
}


public protocol RustMainViewModelProtocol {
    func addUpdateListener(updater: MainViewModelUpdater)  
    func asyncDo() async 
    func currentFocusRegion()   -> FocusRegion
    func handleKeyInput(keyInput: KeyAwareEvent)   -> Bool
    func selectFirstFilteredTab()  
    func selectedCluster()   -> Cluster?
    func selectedTab()   -> TabId
    func setCurrentFocusRegion(currentFocusRegion: FocusRegion)  
    func setSelectedCluster(cluster: Cluster)  
    func setSelectedTab(selectedTab: TabId)  
    func setTabGroupExpansions(tabGroupExpansions: [TabGroupId: Bool])  
    func setWindowClosed()  
    func tabGroupExpansions()   -> [TabGroupId: Bool]
    func tabGroupsFiltered(search: String)   -> [TabGroup]
    func tabs()   -> [Tab]
    func tabsMap()   -> [TabId: Tab]
    
}

public class RustMainViewModel: RustMainViewModelProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(windowId: String)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_kube_viewer_fn_constructor_rustmainviewmodel_new(
        FfiConverterString.lower(windowId),$0)
})
    }

    deinit {
        try! rustCall { uniffi_kube_viewer_fn_free_rustmainviewmodel(pointer, $0) }
    }

    

    
    

    public func addUpdateListener(updater: MainViewModelUpdater)  {
        try! 
    rustCall() {
    
    uniffi_kube_viewer_fn_method_rustmainviewmodel_add_update_listener(self.pointer, 
        FfiConverterCallbackInterfaceMainViewModelUpdater.lower(updater),$0
    )
}
    }

    public func asyncDo() async  {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try!  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_kube_viewer_fn_method_rustmainviewmodel_async_do(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoid,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func currentFocusRegion()  -> FocusRegion {
        return try!  FfiConverterTypeFocusRegion.lift(
            try! 
    rustCall() {
    
    uniffi_kube_viewer_fn_method_rustmainviewmodel_current_focus_region(self.pointer, $0
    )
}
        )
    }

    public func handleKeyInput(keyInput: KeyAwareEvent)  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_kube_viewer_fn_method_rustmainviewmodel_handle_key_input(self.pointer, 
        FfiConverterTypeKeyAwareEvent.lower(keyInput),$0
    )
}
        )
    }

    public func selectFirstFilteredTab()  {
        try! 
    rustCall() {
    
    uniffi_kube_viewer_fn_method_rustmainviewmodel_select_first_filtered_tab(self.pointer, $0
    )
}
    }

    public func selectedCluster()  -> Cluster? {
        return try!  FfiConverterOptionTypeCluster.lift(
            try! 
    rustCall() {
    
    uniffi_kube_viewer_fn_method_rustmainviewmodel_selected_cluster(self.pointer, $0
    )
}
        )
    }

    public func selectedTab()  -> TabId {
        return try!  FfiConverterTypeTabId.lift(
            try! 
    rustCall() {
    
    uniffi_kube_viewer_fn_method_rustmainviewmodel_selected_tab(self.pointer, $0
    )
}
        )
    }

    public func setCurrentFocusRegion(currentFocusRegion: FocusRegion)  {
        try! 
    rustCall() {
    
    uniffi_kube_viewer_fn_method_rustmainviewmodel_set_current_focus_region(self.pointer, 
        FfiConverterTypeFocusRegion.lower(currentFocusRegion),$0
    )
}
    }

    public func setSelectedCluster(cluster: Cluster)  {
        try! 
    rustCall() {
    
    uniffi_kube_viewer_fn_method_rustmainviewmodel_set_selected_cluster(self.pointer, 
        FfiConverterTypeCluster.lower(cluster),$0
    )
}
    }

    public func setSelectedTab(selectedTab: TabId)  {
        try! 
    rustCall() {
    
    uniffi_kube_viewer_fn_method_rustmainviewmodel_set_selected_tab(self.pointer, 
        FfiConverterTypeTabId.lower(selectedTab),$0
    )
}
    }

    public func setTabGroupExpansions(tabGroupExpansions: [TabGroupId: Bool])  {
        try! 
    rustCall() {
    
    uniffi_kube_viewer_fn_method_rustmainviewmodel_set_tab_group_expansions(self.pointer, 
        FfiConverterDictionaryTypeTabGroupIdBool.lower(tabGroupExpansions),$0
    )
}
    }

    public func setWindowClosed()  {
        try! 
    rustCall() {
    
    uniffi_kube_viewer_fn_method_rustmainviewmodel_set_window_closed(self.pointer, $0
    )
}
    }

    public func tabGroupExpansions()  -> [TabGroupId: Bool] {
        return try!  FfiConverterDictionaryTypeTabGroupIdBool.lift(
            try! 
    rustCall() {
    
    uniffi_kube_viewer_fn_method_rustmainviewmodel_tab_group_expansions(self.pointer, $0
    )
}
        )
    }

    public func tabGroupsFiltered(search: String)  -> [TabGroup] {
        return try!  FfiConverterSequenceTypeTabGroup.lift(
            try! 
    rustCall() {
    
    uniffi_kube_viewer_fn_method_rustmainviewmodel_tab_groups_filtered(self.pointer, 
        FfiConverterString.lower(search),$0
    )
}
        )
    }

    public func tabs()  -> [Tab] {
        return try!  FfiConverterSequenceTypeTab.lift(
            try! 
    rustCall() {
    
    uniffi_kube_viewer_fn_method_rustmainviewmodel_tabs(self.pointer, $0
    )
}
        )
    }

    public func tabsMap()  -> [TabId: Tab] {
        return try!  FfiConverterDictionaryTypeTabIdTypeTab.lift(
            try! 
    rustCall() {
    
    uniffi_kube_viewer_fn_method_rustmainviewmodel_tabs_map(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeRustMainViewModel: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RustMainViewModel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustMainViewModel {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RustMainViewModel, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RustMainViewModel {
        return RustMainViewModel(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RustMainViewModel) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeRustMainViewModel_lift(_ pointer: UnsafeMutableRawPointer) throws -> RustMainViewModel {
    return try FfiConverterTypeRustMainViewModel.lift(pointer)
}

public func FfiConverterTypeRustMainViewModel_lower(_ value: RustMainViewModel) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRustMainViewModel.lower(value)
}


public protocol RustNodeViewModelProtocol {
    func addCallbackListener(responder: NodeViewModelCallback) async 
    func fetchNodes(selectedCluster: ClusterId) async 
    func nodes(selectedCluster: ClusterId)   -> [Node]
    func stopWatcher() async 
    
}

public class RustNodeViewModel: RustNodeViewModelProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(windowId: String)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_kube_viewer_fn_constructor_rustnodeviewmodel_new(
        FfiConverterString.lower(windowId),$0)
})
    }

    deinit {
        try! rustCall { uniffi_kube_viewer_fn_free_rustnodeviewmodel(pointer, $0) }
    }

    

    public static func preview(windowId: String)  -> RustNodeViewModel {
        return RustNodeViewModel(unsafeFromRawPointer: try! rustCall() {
    uniffi_kube_viewer_fn_constructor_rustnodeviewmodel_preview(
        FfiConverterString.lower(windowId),$0)
})
    }

    

    
    

    public func addCallbackListener(responder: NodeViewModelCallback) async  {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try!  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_kube_viewer_fn_method_rustnodeviewmodel_add_callback_listener(
                    self.pointer,
                    
        FfiConverterCallbackInterfaceNodeViewModelCallback.lower(responder),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoid,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func fetchNodes(selectedCluster: ClusterId) async  {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try!  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_kube_viewer_fn_method_rustnodeviewmodel_fetch_nodes(
                    self.pointer,
                    
        FfiConverterTypeClusterId.lower(selectedCluster),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoid,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func nodes(selectedCluster: ClusterId)  -> [Node] {
        return try!  FfiConverterSequenceTypeNode.lift(
            try! 
    rustCall() {
    
    uniffi_kube_viewer_fn_method_rustnodeviewmodel_nodes(self.pointer, 
        FfiConverterTypeClusterId.lower(selectedCluster),$0
    )
}
        )
    }

    public func stopWatcher() async  {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try!  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_kube_viewer_fn_method_rustnodeviewmodel_stop_watcher(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoid,
                    &continuation,
                    $0
                )
            }
        }
    }

    
}

public struct FfiConverterTypeRustNodeViewModel: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RustNodeViewModel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustNodeViewModel {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RustNodeViewModel, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RustNodeViewModel {
        return RustNodeViewModel(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RustNodeViewModel) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeRustNodeViewModel_lift(_ pointer: UnsafeMutableRawPointer) throws -> RustNodeViewModel {
    return try FfiConverterTypeRustNodeViewModel.lift(pointer)
}

public func FfiConverterTypeRustNodeViewModel_lower(_ value: RustNodeViewModel) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRustNodeViewModel.lower(value)
}


public protocol RustPodViewModelProtocol {
    func deletePod(selectedCluster: ClusterId, podId: PodId) async 
    func deletePods(selectedCluster: ClusterId, podIds: [PodId]) async 
    func fetchPods(selectedCluster: ClusterId) async 
    func initializeModelWithResponder(responder: PodViewModelCallback) async 
    func pods()   -> [Pod]
    func startWatcher(selectedCluster: ClusterId) async 
    func stopWatcher() async 
    
}

public class RustPodViewModel: RustPodViewModelProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_kube_viewer_fn_constructor_rustpodviewmodel_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_kube_viewer_fn_free_rustpodviewmodel(pointer, $0) }
    }

    

    public static func preview()  -> RustPodViewModel {
        return RustPodViewModel(unsafeFromRawPointer: try! rustCall() {
    uniffi_kube_viewer_fn_constructor_rustpodviewmodel_preview($0)
})
    }

    

    
    

    public func deletePod(selectedCluster: ClusterId, podId: PodId) async  {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try!  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_kube_viewer_fn_method_rustpodviewmodel_delete_pod(
                    self.pointer,
                    
        FfiConverterTypeClusterId.lower(selectedCluster),
        FfiConverterTypePodId.lower(podId),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoid,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func deletePods(selectedCluster: ClusterId, podIds: [PodId]) async  {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try!  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_kube_viewer_fn_method_rustpodviewmodel_delete_pods(
                    self.pointer,
                    
        FfiConverterTypeClusterId.lower(selectedCluster),
        FfiConverterSequenceTypePodId.lower(podIds),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoid,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func fetchPods(selectedCluster: ClusterId) async  {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try!  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_kube_viewer_fn_method_rustpodviewmodel_fetch_pods(
                    self.pointer,
                    
        FfiConverterTypeClusterId.lower(selectedCluster),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoid,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func initializeModelWithResponder(responder: PodViewModelCallback) async  {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try!  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_kube_viewer_fn_method_rustpodviewmodel_initialize_model_with_responder(
                    self.pointer,
                    
        FfiConverterCallbackInterfacePodViewModelCallback.lower(responder),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoid,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func pods()  -> [Pod] {
        return try!  FfiConverterSequenceTypePod.lift(
            try! 
    rustCall() {
    
    uniffi_kube_viewer_fn_method_rustpodviewmodel_pods(self.pointer, $0
    )
}
        )
    }

    public func startWatcher(selectedCluster: ClusterId) async  {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try!  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_kube_viewer_fn_method_rustpodviewmodel_start_watcher(
                    self.pointer,
                    
        FfiConverterTypeClusterId.lower(selectedCluster),
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoid,
                    &continuation,
                    $0
                )
            }
        }
    }

    

    public func stopWatcher() async  {
        // Suspend the function and call the scaffolding function, passing it a callback handler from
        // `AsyncTypes.swift`
        //
        // Make sure to hold on to a reference to the continuation in the top-level scope so that
        // it's not freed before the callback is invoked.
        var continuation: CheckedContinuation<(), Error>? = nil
        return try!  await withCheckedThrowingContinuation {
            continuation = $0
            try! rustCall() {
                uniffi_kube_viewer_fn_method_rustpodviewmodel_stop_watcher(
                    self.pointer,
                    
                    FfiConverterForeignExecutor.lower(UniFfiForeignExecutor()),
                    uniffiFutureCallbackHandlerVoid,
                    &continuation,
                    $0
                )
            }
        }
    }

    
}

public struct FfiConverterTypeRustPodViewModel: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RustPodViewModel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RustPodViewModel {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RustPodViewModel, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RustPodViewModel {
        return RustPodViewModel(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RustPodViewModel) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeRustPodViewModel_lift(_ pointer: UnsafeMutableRawPointer) throws -> RustPodViewModel {
    return try FfiConverterTypeRustPodViewModel.lift(pointer)
}

public func FfiConverterTypeRustPodViewModel_lower(_ value: RustPodViewModel) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRustPodViewModel.lower(value)
}

private let UNIFFI_RUST_TASK_CALLBACK_SUCCESS: Int8 = 0
private let UNIFFI_RUST_TASK_CALLBACK_CANCELLED: Int8 = 1
private let UNIFFI_FOREIGN_EXECUTOR_CALLBACK_SUCCESS: Int8 = 0
private let UNIFFI_FOREIGN_EXECUTOR_CALLBACK_CANCELED: Int8 = 1
private let UNIFFI_FOREIGN_EXECUTOR_CALLBACK_ERROR: Int8 = 2

// Encapsulates an executor that can run Rust tasks
//
// On Swift, `Task.detached` can handle this we just need to know what priority to send it.
public struct UniFfiForeignExecutor {
    var priority: TaskPriority

    public init(priority: TaskPriority) {
        self.priority = priority
    }

    public init() {
        self.priority = Task.currentPriority
    }
}

fileprivate struct FfiConverterForeignExecutor: FfiConverter {
    typealias SwiftType = UniFfiForeignExecutor
    // Rust uses a pointer to represent the FfiConverterForeignExecutor, but we only need a u8.
    // let's use `Int`, which is equivalent to `size_t`
    typealias FfiType = Int

    public static func lift(_ value: FfiType) throws -> SwiftType {
        UniFfiForeignExecutor(priority: TaskPriority(rawValue: numericCast(value)))
    }
    public static func lower(_ value: SwiftType) -> FfiType {
        numericCast(value.priority.rawValue)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        fatalError("FfiConverterForeignExecutor.read not implemented yet")
    }
    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        fatalError("FfiConverterForeignExecutor.read not implemented yet")
    }
}


fileprivate func uniffiForeignExecutorCallback(executorHandle: Int, delayMs: UInt32, rustTask: UniFfiRustTaskCallback?, taskData: UnsafeRawPointer?) -> Int8 {
    if let rustTask = rustTask {
        let executor = try! FfiConverterForeignExecutor.lift(executorHandle)
        Task.detached(priority: executor.priority) {
            if delayMs != 0 {
                let nanoseconds: UInt64 = numericCast(delayMs * 1000000)
                try! await Task.sleep(nanoseconds: nanoseconds)
            }
            rustTask(taskData, UNIFFI_RUST_TASK_CALLBACK_SUCCESS)
        }
        return UNIFFI_FOREIGN_EXECUTOR_CALLBACK_SUCCESS
    } else {
        // When rustTask is null, we should drop the foreign executor.
        // However, since its just a value type, we don't need to do anything here.
        return UNIFFI_FOREIGN_EXECUTOR_CALLBACK_SUCCESS
    }
}

fileprivate func uniffiInitForeignExecutor() {
    ffi_kube_viewer_foreign_executor_callback_set(uniffiForeignExecutorCallback)
}


public struct Cluster {
    public var id: ClusterId
    public var server: String?
    public var proxyUrl: String?
    public var nickname: String?
    public var loadStatus: SimpleLoadStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: ClusterId, server: String?, proxyUrl: String?, nickname: String?, loadStatus: SimpleLoadStatus) {
        self.id = id
        self.server = server
        self.proxyUrl = proxyUrl
        self.nickname = nickname
        self.loadStatus = loadStatus
    }
}


extension Cluster: Equatable, Hashable {
    public static func ==(lhs: Cluster, rhs: Cluster) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.server != rhs.server {
            return false
        }
        if lhs.proxyUrl != rhs.proxyUrl {
            return false
        }
        if lhs.nickname != rhs.nickname {
            return false
        }
        if lhs.loadStatus != rhs.loadStatus {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(server)
        hasher.combine(proxyUrl)
        hasher.combine(nickname)
        hasher.combine(loadStatus)
    }
}


public struct FfiConverterTypeCluster: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Cluster {
        return try Cluster(
            id: FfiConverterTypeClusterId.read(from: &buf), 
            server: FfiConverterOptionString.read(from: &buf), 
            proxyUrl: FfiConverterOptionString.read(from: &buf), 
            nickname: FfiConverterOptionString.read(from: &buf), 
            loadStatus: FfiConverterTypeSimpleLoadStatus.read(from: &buf)
        )
    }

    public static func write(_ value: Cluster, into buf: inout [UInt8]) {
        FfiConverterTypeClusterId.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.server, into: &buf)
        FfiConverterOptionString.write(value.proxyUrl, into: &buf)
        FfiConverterOptionString.write(value.nickname, into: &buf)
        FfiConverterTypeSimpleLoadStatus.write(value.loadStatus, into: &buf)
    }
}


public func FfiConverterTypeCluster_lift(_ buf: RustBuffer) throws -> Cluster {
    return try FfiConverterTypeCluster.lift(buf)
}

public func FfiConverterTypeCluster_lower(_ value: Cluster) -> RustBuffer {
    return FfiConverterTypeCluster.lower(value)
}


public struct ClusterId {
    public var rawValue: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(rawValue: String) {
        self.rawValue = rawValue
    }
}


extension ClusterId: Equatable, Hashable {
    public static func ==(lhs: ClusterId, rhs: ClusterId) -> Bool {
        if lhs.rawValue != rhs.rawValue {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(rawValue)
    }
}


public struct FfiConverterTypeClusterId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClusterId {
        return try ClusterId(
            rawValue: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ClusterId, into buf: inout [UInt8]) {
        FfiConverterString.write(value.rawValue, into: &buf)
    }
}


public func FfiConverterTypeClusterId_lift(_ buf: RustBuffer) throws -> ClusterId {
    return try FfiConverterTypeClusterId.lift(buf)
}

public func FfiConverterTypeClusterId_lower(_ value: ClusterId) -> RustBuffer {
    return FfiConverterTypeClusterId.lower(value)
}


public struct Container {
    public var id: ContainerId
    public var name: String
    public var image: String
    public var imageId: String?
    public var lastState: ContainerState?
    public var ready: Bool
    public var restartCount: Int32
    public var started: Bool
    public var state: ContainerState?
    public var ports: [UInt32]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: ContainerId, name: String, image: String, imageId: String?, lastState: ContainerState?, ready: Bool, restartCount: Int32, started: Bool, state: ContainerState?, ports: [UInt32]) {
        self.id = id
        self.name = name
        self.image = image
        self.imageId = imageId
        self.lastState = lastState
        self.ready = ready
        self.restartCount = restartCount
        self.started = started
        self.state = state
        self.ports = ports
    }
}


extension Container: Equatable, Hashable {
    public static func ==(lhs: Container, rhs: Container) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.image != rhs.image {
            return false
        }
        if lhs.imageId != rhs.imageId {
            return false
        }
        if lhs.lastState != rhs.lastState {
            return false
        }
        if lhs.ready != rhs.ready {
            return false
        }
        if lhs.restartCount != rhs.restartCount {
            return false
        }
        if lhs.started != rhs.started {
            return false
        }
        if lhs.state != rhs.state {
            return false
        }
        if lhs.ports != rhs.ports {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(image)
        hasher.combine(imageId)
        hasher.combine(lastState)
        hasher.combine(ready)
        hasher.combine(restartCount)
        hasher.combine(started)
        hasher.combine(state)
        hasher.combine(ports)
    }
}


public struct FfiConverterTypeContainer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Container {
        return try Container(
            id: FfiConverterTypeContainerId.read(from: &buf), 
            name: FfiConverterString.read(from: &buf), 
            image: FfiConverterString.read(from: &buf), 
            imageId: FfiConverterOptionString.read(from: &buf), 
            lastState: FfiConverterOptionTypeContainerState.read(from: &buf), 
            ready: FfiConverterBool.read(from: &buf), 
            restartCount: FfiConverterInt32.read(from: &buf), 
            started: FfiConverterBool.read(from: &buf), 
            state: FfiConverterOptionTypeContainerState.read(from: &buf), 
            ports: FfiConverterSequenceUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: Container, into buf: inout [UInt8]) {
        FfiConverterTypeContainerId.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.image, into: &buf)
        FfiConverterOptionString.write(value.imageId, into: &buf)
        FfiConverterOptionTypeContainerState.write(value.lastState, into: &buf)
        FfiConverterBool.write(value.ready, into: &buf)
        FfiConverterInt32.write(value.restartCount, into: &buf)
        FfiConverterBool.write(value.started, into: &buf)
        FfiConverterOptionTypeContainerState.write(value.state, into: &buf)
        FfiConverterSequenceUInt32.write(value.ports, into: &buf)
    }
}


public func FfiConverterTypeContainer_lift(_ buf: RustBuffer) throws -> Container {
    return try FfiConverterTypeContainer.lift(buf)
}

public func FfiConverterTypeContainer_lower(_ value: Container) -> RustBuffer {
    return FfiConverterTypeContainer.lower(value)
}


public struct ContainerStateRunning {
    public var startedAt: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(startedAt: Int64) {
        self.startedAt = startedAt
    }
}


extension ContainerStateRunning: Equatable, Hashable {
    public static func ==(lhs: ContainerStateRunning, rhs: ContainerStateRunning) -> Bool {
        if lhs.startedAt != rhs.startedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(startedAt)
    }
}


public struct FfiConverterTypeContainerStateRunning: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContainerStateRunning {
        return try ContainerStateRunning(
            startedAt: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ContainerStateRunning, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.startedAt, into: &buf)
    }
}


public func FfiConverterTypeContainerStateRunning_lift(_ buf: RustBuffer) throws -> ContainerStateRunning {
    return try FfiConverterTypeContainerStateRunning.lift(buf)
}

public func FfiConverterTypeContainerStateRunning_lower(_ value: ContainerStateRunning) -> RustBuffer {
    return FfiConverterTypeContainerStateRunning.lower(value)
}


public struct ContainerStateTerminated {
    public var startedAt: Int64
    public var finishedAt: Int64
    public var exitCode: Int32
    public var message: String?
    public var reason: String?
    public var signal: Int32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(startedAt: Int64, finishedAt: Int64, exitCode: Int32, message: String?, reason: String?, signal: Int32?) {
        self.startedAt = startedAt
        self.finishedAt = finishedAt
        self.exitCode = exitCode
        self.message = message
        self.reason = reason
        self.signal = signal
    }
}


extension ContainerStateTerminated: Equatable, Hashable {
    public static func ==(lhs: ContainerStateTerminated, rhs: ContainerStateTerminated) -> Bool {
        if lhs.startedAt != rhs.startedAt {
            return false
        }
        if lhs.finishedAt != rhs.finishedAt {
            return false
        }
        if lhs.exitCode != rhs.exitCode {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.reason != rhs.reason {
            return false
        }
        if lhs.signal != rhs.signal {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(startedAt)
        hasher.combine(finishedAt)
        hasher.combine(exitCode)
        hasher.combine(message)
        hasher.combine(reason)
        hasher.combine(signal)
    }
}


public struct FfiConverterTypeContainerStateTerminated: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContainerStateTerminated {
        return try ContainerStateTerminated(
            startedAt: FfiConverterInt64.read(from: &buf), 
            finishedAt: FfiConverterInt64.read(from: &buf), 
            exitCode: FfiConverterInt32.read(from: &buf), 
            message: FfiConverterOptionString.read(from: &buf), 
            reason: FfiConverterOptionString.read(from: &buf), 
            signal: FfiConverterOptionInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ContainerStateTerminated, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.startedAt, into: &buf)
        FfiConverterInt64.write(value.finishedAt, into: &buf)
        FfiConverterInt32.write(value.exitCode, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
        FfiConverterOptionString.write(value.reason, into: &buf)
        FfiConverterOptionInt32.write(value.signal, into: &buf)
    }
}


public func FfiConverterTypeContainerStateTerminated_lift(_ buf: RustBuffer) throws -> ContainerStateTerminated {
    return try FfiConverterTypeContainerStateTerminated.lift(buf)
}

public func FfiConverterTypeContainerStateTerminated_lower(_ value: ContainerStateTerminated) -> RustBuffer {
    return FfiConverterTypeContainerStateTerminated.lower(value)
}


public struct ContainerStateWaiting {
    public var message: String?
    public var reason: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(message: String?, reason: String?) {
        self.message = message
        self.reason = reason
    }
}


extension ContainerStateWaiting: Equatable, Hashable {
    public static func ==(lhs: ContainerStateWaiting, rhs: ContainerStateWaiting) -> Bool {
        if lhs.message != rhs.message {
            return false
        }
        if lhs.reason != rhs.reason {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(message)
        hasher.combine(reason)
    }
}


public struct FfiConverterTypeContainerStateWaiting: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContainerStateWaiting {
        return try ContainerStateWaiting(
            message: FfiConverterOptionString.read(from: &buf), 
            reason: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ContainerStateWaiting, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.message, into: &buf)
        FfiConverterOptionString.write(value.reason, into: &buf)
    }
}


public func FfiConverterTypeContainerStateWaiting_lift(_ buf: RustBuffer) throws -> ContainerStateWaiting {
    return try FfiConverterTypeContainerStateWaiting.lift(buf)
}

public func FfiConverterTypeContainerStateWaiting_lower(_ value: ContainerStateWaiting) -> RustBuffer {
    return FfiConverterTypeContainerStateWaiting.lower(value)
}


public struct Node {
    public var id: NodeId
    public var name: String
    public var createdAt: Int64?
    public var labels: [String: String]
    public var annotations: [String: String]
    public var taints: [Taint]
    public var addresses: [NodeAddress]
    public var os: String?
    public var arch: String?
    public var osImage: String?
    public var kernelVersion: String?
    public var containerRuntime: String?
    public var kubeletVersion: String?
    public var conditions: [NodeCondition]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: NodeId, name: String, createdAt: Int64?, labels: [String: String], annotations: [String: String], taints: [Taint], addresses: [NodeAddress], os: String?, arch: String?, osImage: String?, kernelVersion: String?, containerRuntime: String?, kubeletVersion: String?, conditions: [NodeCondition]) {
        self.id = id
        self.name = name
        self.createdAt = createdAt
        self.labels = labels
        self.annotations = annotations
        self.taints = taints
        self.addresses = addresses
        self.os = os
        self.arch = arch
        self.osImage = osImage
        self.kernelVersion = kernelVersion
        self.containerRuntime = containerRuntime
        self.kubeletVersion = kubeletVersion
        self.conditions = conditions
    }
}


extension Node: Equatable, Hashable {
    public static func ==(lhs: Node, rhs: Node) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.labels != rhs.labels {
            return false
        }
        if lhs.annotations != rhs.annotations {
            return false
        }
        if lhs.taints != rhs.taints {
            return false
        }
        if lhs.addresses != rhs.addresses {
            return false
        }
        if lhs.os != rhs.os {
            return false
        }
        if lhs.arch != rhs.arch {
            return false
        }
        if lhs.osImage != rhs.osImage {
            return false
        }
        if lhs.kernelVersion != rhs.kernelVersion {
            return false
        }
        if lhs.containerRuntime != rhs.containerRuntime {
            return false
        }
        if lhs.kubeletVersion != rhs.kubeletVersion {
            return false
        }
        if lhs.conditions != rhs.conditions {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(createdAt)
        hasher.combine(labels)
        hasher.combine(annotations)
        hasher.combine(taints)
        hasher.combine(addresses)
        hasher.combine(os)
        hasher.combine(arch)
        hasher.combine(osImage)
        hasher.combine(kernelVersion)
        hasher.combine(containerRuntime)
        hasher.combine(kubeletVersion)
        hasher.combine(conditions)
    }
}


public struct FfiConverterTypeNode: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Node {
        return try Node(
            id: FfiConverterTypeNodeId.read(from: &buf), 
            name: FfiConverterString.read(from: &buf), 
            createdAt: FfiConverterOptionInt64.read(from: &buf), 
            labels: FfiConverterDictionaryStringString.read(from: &buf), 
            annotations: FfiConverterDictionaryStringString.read(from: &buf), 
            taints: FfiConverterSequenceTypeTaint.read(from: &buf), 
            addresses: FfiConverterSequenceTypeNodeAddress.read(from: &buf), 
            os: FfiConverterOptionString.read(from: &buf), 
            arch: FfiConverterOptionString.read(from: &buf), 
            osImage: FfiConverterOptionString.read(from: &buf), 
            kernelVersion: FfiConverterOptionString.read(from: &buf), 
            containerRuntime: FfiConverterOptionString.read(from: &buf), 
            kubeletVersion: FfiConverterOptionString.read(from: &buf), 
            conditions: FfiConverterSequenceTypeNodeCondition.read(from: &buf)
        )
    }

    public static func write(_ value: Node, into buf: inout [UInt8]) {
        FfiConverterTypeNodeId.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionInt64.write(value.createdAt, into: &buf)
        FfiConverterDictionaryStringString.write(value.labels, into: &buf)
        FfiConverterDictionaryStringString.write(value.annotations, into: &buf)
        FfiConverterSequenceTypeTaint.write(value.taints, into: &buf)
        FfiConverterSequenceTypeNodeAddress.write(value.addresses, into: &buf)
        FfiConverterOptionString.write(value.os, into: &buf)
        FfiConverterOptionString.write(value.arch, into: &buf)
        FfiConverterOptionString.write(value.osImage, into: &buf)
        FfiConverterOptionString.write(value.kernelVersion, into: &buf)
        FfiConverterOptionString.write(value.containerRuntime, into: &buf)
        FfiConverterOptionString.write(value.kubeletVersion, into: &buf)
        FfiConverterSequenceTypeNodeCondition.write(value.conditions, into: &buf)
    }
}


public func FfiConverterTypeNode_lift(_ buf: RustBuffer) throws -> Node {
    return try FfiConverterTypeNode.lift(buf)
}

public func FfiConverterTypeNode_lower(_ value: Node) -> RustBuffer {
    return FfiConverterTypeNode.lower(value)
}


public struct NodeAddress {
    public var address: String
    public var nodeType: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(address: String, nodeType: String) {
        self.address = address
        self.nodeType = nodeType
    }
}


extension NodeAddress: Equatable, Hashable {
    public static func ==(lhs: NodeAddress, rhs: NodeAddress) -> Bool {
        if lhs.address != rhs.address {
            return false
        }
        if lhs.nodeType != rhs.nodeType {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(address)
        hasher.combine(nodeType)
    }
}


public struct FfiConverterTypeNodeAddress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeAddress {
        return try NodeAddress(
            address: FfiConverterString.read(from: &buf), 
            nodeType: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: NodeAddress, into buf: inout [UInt8]) {
        FfiConverterString.write(value.address, into: &buf)
        FfiConverterString.write(value.nodeType, into: &buf)
    }
}


public func FfiConverterTypeNodeAddress_lift(_ buf: RustBuffer) throws -> NodeAddress {
    return try FfiConverterTypeNodeAddress.lift(buf)
}

public func FfiConverterTypeNodeAddress_lower(_ value: NodeAddress) -> RustBuffer {
    return FfiConverterTypeNodeAddress.lower(value)
}


public struct NodeCondition {
    public var name: String
    public var status: String
    public var reason: String?
    public var message: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, status: String, reason: String?, message: String?) {
        self.name = name
        self.status = status
        self.reason = reason
        self.message = message
    }
}


extension NodeCondition: Equatable, Hashable {
    public static func ==(lhs: NodeCondition, rhs: NodeCondition) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.reason != rhs.reason {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(status)
        hasher.combine(reason)
        hasher.combine(message)
    }
}


public struct FfiConverterTypeNodeCondition: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeCondition {
        return try NodeCondition(
            name: FfiConverterString.read(from: &buf), 
            status: FfiConverterString.read(from: &buf), 
            reason: FfiConverterOptionString.read(from: &buf), 
            message: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: NodeCondition, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.status, into: &buf)
        FfiConverterOptionString.write(value.reason, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
    }
}


public func FfiConverterTypeNodeCondition_lift(_ buf: RustBuffer) throws -> NodeCondition {
    return try FfiConverterTypeNodeCondition.lift(buf)
}

public func FfiConverterTypeNodeCondition_lower(_ value: NodeCondition) -> RustBuffer {
    return FfiConverterTypeNodeCondition.lower(value)
}


public struct NodeId {
    public var rawValue: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(rawValue: String) {
        self.rawValue = rawValue
    }
}


extension NodeId: Equatable, Hashable {
    public static func ==(lhs: NodeId, rhs: NodeId) -> Bool {
        if lhs.rawValue != rhs.rawValue {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(rawValue)
    }
}


public struct FfiConverterTypeNodeId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeId {
        return try NodeId(
            rawValue: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: NodeId, into buf: inout [UInt8]) {
        FfiConverterString.write(value.rawValue, into: &buf)
    }
}


public func FfiConverterTypeNodeId_lift(_ buf: RustBuffer) throws -> NodeId {
    return try FfiConverterTypeNodeId.lift(buf)
}

public func FfiConverterTypeNodeId_lower(_ value: NodeId) -> RustBuffer {
    return FfiConverterTypeNodeId.lower(value)
}


public struct OwnerReference {
    public var apiVersion: String
    public var blockOwnerDeletion: Bool
    public var controller: Bool
    public var kind: String
    public var name: String
    public var uid: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(apiVersion: String, blockOwnerDeletion: Bool, controller: Bool, kind: String, name: String, uid: String) {
        self.apiVersion = apiVersion
        self.blockOwnerDeletion = blockOwnerDeletion
        self.controller = controller
        self.kind = kind
        self.name = name
        self.uid = uid
    }
}


extension OwnerReference: Equatable, Hashable {
    public static func ==(lhs: OwnerReference, rhs: OwnerReference) -> Bool {
        if lhs.apiVersion != rhs.apiVersion {
            return false
        }
        if lhs.blockOwnerDeletion != rhs.blockOwnerDeletion {
            return false
        }
        if lhs.controller != rhs.controller {
            return false
        }
        if lhs.kind != rhs.kind {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.uid != rhs.uid {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(apiVersion)
        hasher.combine(blockOwnerDeletion)
        hasher.combine(controller)
        hasher.combine(kind)
        hasher.combine(name)
        hasher.combine(uid)
    }
}


public struct FfiConverterTypeOwnerReference: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OwnerReference {
        return try OwnerReference(
            apiVersion: FfiConverterString.read(from: &buf), 
            blockOwnerDeletion: FfiConverterBool.read(from: &buf), 
            controller: FfiConverterBool.read(from: &buf), 
            kind: FfiConverterString.read(from: &buf), 
            name: FfiConverterString.read(from: &buf), 
            uid: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: OwnerReference, into buf: inout [UInt8]) {
        FfiConverterString.write(value.apiVersion, into: &buf)
        FfiConverterBool.write(value.blockOwnerDeletion, into: &buf)
        FfiConverterBool.write(value.controller, into: &buf)
        FfiConverterString.write(value.kind, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.uid, into: &buf)
    }
}


public func FfiConverterTypeOwnerReference_lift(_ buf: RustBuffer) throws -> OwnerReference {
    return try FfiConverterTypeOwnerReference.lift(buf)
}

public func FfiConverterTypeOwnerReference_lower(_ value: OwnerReference) -> RustBuffer {
    return FfiConverterTypeOwnerReference.lower(value)
}


public struct Pod {
    public var id: PodId
    public var name: String
    public var namespace: String
    public var createdAt: Int64?
    public var labels: [String: String]
    public var annotations: [String: String]
    public var containers: [Container]
    public var podIp: String?
    public var hostIp: String?
    public var podIps: [String]
    public var qosClass: String?
    public var message: String?
    public var phase: Phase
    public var controlledBy: [OwnerReference]
    public var serviceAccount: String?
    public var conditions: [PodCondition]
    public var tolerations: [Toleration]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: PodId, name: String, namespace: String, createdAt: Int64?, labels: [String: String], annotations: [String: String], containers: [Container], podIp: String?, hostIp: String?, podIps: [String], qosClass: String?, message: String?, phase: Phase, controlledBy: [OwnerReference], serviceAccount: String?, conditions: [PodCondition], tolerations: [Toleration]) {
        self.id = id
        self.name = name
        self.namespace = namespace
        self.createdAt = createdAt
        self.labels = labels
        self.annotations = annotations
        self.containers = containers
        self.podIp = podIp
        self.hostIp = hostIp
        self.podIps = podIps
        self.qosClass = qosClass
        self.message = message
        self.phase = phase
        self.controlledBy = controlledBy
        self.serviceAccount = serviceAccount
        self.conditions = conditions
        self.tolerations = tolerations
    }
}


extension Pod: Equatable, Hashable {
    public static func ==(lhs: Pod, rhs: Pod) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.namespace != rhs.namespace {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.labels != rhs.labels {
            return false
        }
        if lhs.annotations != rhs.annotations {
            return false
        }
        if lhs.containers != rhs.containers {
            return false
        }
        if lhs.podIp != rhs.podIp {
            return false
        }
        if lhs.hostIp != rhs.hostIp {
            return false
        }
        if lhs.podIps != rhs.podIps {
            return false
        }
        if lhs.qosClass != rhs.qosClass {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.phase != rhs.phase {
            return false
        }
        if lhs.controlledBy != rhs.controlledBy {
            return false
        }
        if lhs.serviceAccount != rhs.serviceAccount {
            return false
        }
        if lhs.conditions != rhs.conditions {
            return false
        }
        if lhs.tolerations != rhs.tolerations {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(namespace)
        hasher.combine(createdAt)
        hasher.combine(labels)
        hasher.combine(annotations)
        hasher.combine(containers)
        hasher.combine(podIp)
        hasher.combine(hostIp)
        hasher.combine(podIps)
        hasher.combine(qosClass)
        hasher.combine(message)
        hasher.combine(phase)
        hasher.combine(controlledBy)
        hasher.combine(serviceAccount)
        hasher.combine(conditions)
        hasher.combine(tolerations)
    }
}


public struct FfiConverterTypePod: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Pod {
        return try Pod(
            id: FfiConverterTypePodId.read(from: &buf), 
            name: FfiConverterString.read(from: &buf), 
            namespace: FfiConverterString.read(from: &buf), 
            createdAt: FfiConverterOptionInt64.read(from: &buf), 
            labels: FfiConverterDictionaryStringString.read(from: &buf), 
            annotations: FfiConverterDictionaryStringString.read(from: &buf), 
            containers: FfiConverterSequenceTypeContainer.read(from: &buf), 
            podIp: FfiConverterOptionString.read(from: &buf), 
            hostIp: FfiConverterOptionString.read(from: &buf), 
            podIps: FfiConverterSequenceString.read(from: &buf), 
            qosClass: FfiConverterOptionString.read(from: &buf), 
            message: FfiConverterOptionString.read(from: &buf), 
            phase: FfiConverterTypePhase.read(from: &buf), 
            controlledBy: FfiConverterSequenceTypeOwnerReference.read(from: &buf), 
            serviceAccount: FfiConverterOptionString.read(from: &buf), 
            conditions: FfiConverterSequenceTypePodCondition.read(from: &buf), 
            tolerations: FfiConverterSequenceTypeToleration.read(from: &buf)
        )
    }

    public static func write(_ value: Pod, into buf: inout [UInt8]) {
        FfiConverterTypePodId.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.namespace, into: &buf)
        FfiConverterOptionInt64.write(value.createdAt, into: &buf)
        FfiConverterDictionaryStringString.write(value.labels, into: &buf)
        FfiConverterDictionaryStringString.write(value.annotations, into: &buf)
        FfiConverterSequenceTypeContainer.write(value.containers, into: &buf)
        FfiConverterOptionString.write(value.podIp, into: &buf)
        FfiConverterOptionString.write(value.hostIp, into: &buf)
        FfiConverterSequenceString.write(value.podIps, into: &buf)
        FfiConverterOptionString.write(value.qosClass, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
        FfiConverterTypePhase.write(value.phase, into: &buf)
        FfiConverterSequenceTypeOwnerReference.write(value.controlledBy, into: &buf)
        FfiConverterOptionString.write(value.serviceAccount, into: &buf)
        FfiConverterSequenceTypePodCondition.write(value.conditions, into: &buf)
        FfiConverterSequenceTypeToleration.write(value.tolerations, into: &buf)
    }
}


public func FfiConverterTypePod_lift(_ buf: RustBuffer) throws -> Pod {
    return try FfiConverterTypePod.lift(buf)
}

public func FfiConverterTypePod_lower(_ value: Pod) -> RustBuffer {
    return FfiConverterTypePod.lower(value)
}


public struct PodCondition {
    public var lastProbeTime: Int64?
    public var lastTransitionTime: Int64?
    public var message: String?
    public var reason: String?
    public var status: String
    public var type: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lastProbeTime: Int64?, lastTransitionTime: Int64?, message: String?, reason: String?, status: String, type: String) {
        self.lastProbeTime = lastProbeTime
        self.lastTransitionTime = lastTransitionTime
        self.message = message
        self.reason = reason
        self.status = status
        self.type = type
    }
}


extension PodCondition: Equatable, Hashable {
    public static func ==(lhs: PodCondition, rhs: PodCondition) -> Bool {
        if lhs.lastProbeTime != rhs.lastProbeTime {
            return false
        }
        if lhs.lastTransitionTime != rhs.lastTransitionTime {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.reason != rhs.reason {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.type != rhs.type {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lastProbeTime)
        hasher.combine(lastTransitionTime)
        hasher.combine(message)
        hasher.combine(reason)
        hasher.combine(status)
        hasher.combine(type)
    }
}


public struct FfiConverterTypePodCondition: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PodCondition {
        return try PodCondition(
            lastProbeTime: FfiConverterOptionInt64.read(from: &buf), 
            lastTransitionTime: FfiConverterOptionInt64.read(from: &buf), 
            message: FfiConverterOptionString.read(from: &buf), 
            reason: FfiConverterOptionString.read(from: &buf), 
            status: FfiConverterString.read(from: &buf), 
            type: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PodCondition, into buf: inout [UInt8]) {
        FfiConverterOptionInt64.write(value.lastProbeTime, into: &buf)
        FfiConverterOptionInt64.write(value.lastTransitionTime, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
        FfiConverterOptionString.write(value.reason, into: &buf)
        FfiConverterString.write(value.status, into: &buf)
        FfiConverterString.write(value.type, into: &buf)
    }
}


public func FfiConverterTypePodCondition_lift(_ buf: RustBuffer) throws -> PodCondition {
    return try FfiConverterTypePodCondition.lift(buf)
}

public func FfiConverterTypePodCondition_lower(_ value: PodCondition) -> RustBuffer {
    return FfiConverterTypePodCondition.lower(value)
}


public struct Tab {
    public var id: TabId
    public var icon: String
    public var name: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: TabId, icon: String, name: String) {
        self.id = id
        self.icon = icon
        self.name = name
    }
}


extension Tab: Equatable, Hashable {
    public static func ==(lhs: Tab, rhs: Tab) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.icon != rhs.icon {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(icon)
        hasher.combine(name)
    }
}


public struct FfiConverterTypeTab: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Tab {
        return try Tab(
            id: FfiConverterTypeTabId.read(from: &buf), 
            icon: FfiConverterString.read(from: &buf), 
            name: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Tab, into buf: inout [UInt8]) {
        FfiConverterTypeTabId.write(value.id, into: &buf)
        FfiConverterString.write(value.icon, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
    }
}


public func FfiConverterTypeTab_lift(_ buf: RustBuffer) throws -> Tab {
    return try FfiConverterTypeTab.lift(buf)
}

public func FfiConverterTypeTab_lower(_ value: Tab) -> RustBuffer {
    return FfiConverterTypeTab.lower(value)
}


public struct TabGroup {
    public var id: TabGroupId
    public var name: String
    public var tabs: [Tab]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: TabGroupId, name: String, tabs: [Tab]) {
        self.id = id
        self.name = name
        self.tabs = tabs
    }
}


extension TabGroup: Equatable, Hashable {
    public static func ==(lhs: TabGroup, rhs: TabGroup) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.tabs != rhs.tabs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(tabs)
    }
}


public struct FfiConverterTypeTabGroup: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TabGroup {
        return try TabGroup(
            id: FfiConverterTypeTabGroupId.read(from: &buf), 
            name: FfiConverterString.read(from: &buf), 
            tabs: FfiConverterSequenceTypeTab.read(from: &buf)
        )
    }

    public static func write(_ value: TabGroup, into buf: inout [UInt8]) {
        FfiConverterTypeTabGroupId.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterSequenceTypeTab.write(value.tabs, into: &buf)
    }
}


public func FfiConverterTypeTabGroup_lift(_ buf: RustBuffer) throws -> TabGroup {
    return try FfiConverterTypeTabGroup.lift(buf)
}

public func FfiConverterTypeTabGroup_lower(_ value: TabGroup) -> RustBuffer {
    return FfiConverterTypeTabGroup.lower(value)
}


public struct Taint {
    public var effect: String
    public var key: String
    public var timeAdded: String?
    public var value: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(effect: String, key: String, timeAdded: String?, value: String?) {
        self.effect = effect
        self.key = key
        self.timeAdded = timeAdded
        self.value = value
    }
}


extension Taint: Equatable, Hashable {
    public static func ==(lhs: Taint, rhs: Taint) -> Bool {
        if lhs.effect != rhs.effect {
            return false
        }
        if lhs.key != rhs.key {
            return false
        }
        if lhs.timeAdded != rhs.timeAdded {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(effect)
        hasher.combine(key)
        hasher.combine(timeAdded)
        hasher.combine(value)
    }
}


public struct FfiConverterTypeTaint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Taint {
        return try Taint(
            effect: FfiConverterString.read(from: &buf), 
            key: FfiConverterString.read(from: &buf), 
            timeAdded: FfiConverterOptionString.read(from: &buf), 
            value: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Taint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.effect, into: &buf)
        FfiConverterString.write(value.key, into: &buf)
        FfiConverterOptionString.write(value.timeAdded, into: &buf)
        FfiConverterOptionString.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeTaint_lift(_ buf: RustBuffer) throws -> Taint {
    return try FfiConverterTypeTaint.lift(buf)
}

public func FfiConverterTypeTaint_lower(_ value: Taint) -> RustBuffer {
    return FfiConverterTypeTaint.lower(value)
}


public struct Toleration {
    public var effect: String?
    public var key: String?
    public var `operator`: String?
    public var tolerationSeconds: Int64?
    public var value: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(effect: String?, key: String?, `operator`: String?, tolerationSeconds: Int64?, value: String?) {
        self.effect = effect
        self.key = key
        self.`operator` = `operator`
        self.tolerationSeconds = tolerationSeconds
        self.value = value
    }
}


extension Toleration: Equatable, Hashable {
    public static func ==(lhs: Toleration, rhs: Toleration) -> Bool {
        if lhs.effect != rhs.effect {
            return false
        }
        if lhs.key != rhs.key {
            return false
        }
        if lhs.`operator` != rhs.`operator` {
            return false
        }
        if lhs.tolerationSeconds != rhs.tolerationSeconds {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(effect)
        hasher.combine(key)
        hasher.combine(`operator`)
        hasher.combine(tolerationSeconds)
        hasher.combine(value)
    }
}


public struct FfiConverterTypeToleration: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Toleration {
        return try Toleration(
            effect: FfiConverterOptionString.read(from: &buf), 
            key: FfiConverterOptionString.read(from: &buf), 
            operator: FfiConverterOptionString.read(from: &buf), 
            tolerationSeconds: FfiConverterOptionInt64.read(from: &buf), 
            value: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Toleration, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.effect, into: &buf)
        FfiConverterOptionString.write(value.key, into: &buf)
        FfiConverterOptionString.write(value.`operator`, into: &buf)
        FfiConverterOptionInt64.write(value.tolerationSeconds, into: &buf)
        FfiConverterOptionString.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeToleration_lift(_ buf: RustBuffer) throws -> Toleration {
    return try FfiConverterTypeToleration.lift(buf)
}

public func FfiConverterTypeToleration_lower(_ value: Toleration) -> RustBuffer {
    return FfiConverterTypeToleration.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ContainerState {
    
    case running(data: ContainerStateRunning)
    case terminated(data: ContainerStateTerminated)
    case waiting(data: ContainerStateWaiting)
}

public struct FfiConverterTypeContainerState: FfiConverterRustBuffer {
    typealias SwiftType = ContainerState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContainerState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .running(
            data: try FfiConverterTypeContainerStateRunning.read(from: &buf)
        )
        
        case 2: return .terminated(
            data: try FfiConverterTypeContainerStateTerminated.read(from: &buf)
        )
        
        case 3: return .waiting(
            data: try FfiConverterTypeContainerStateWaiting.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ContainerState, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .running(data):
            writeInt(&buf, Int32(1))
            FfiConverterTypeContainerStateRunning.write(data, into: &buf)
            
        
        case let .terminated(data):
            writeInt(&buf, Int32(2))
            FfiConverterTypeContainerStateTerminated.write(data, into: &buf)
            
        
        case let .waiting(data):
            writeInt(&buf, Int32(3))
            FfiConverterTypeContainerStateWaiting.write(data, into: &buf)
            
        }
    }
}


public func FfiConverterTypeContainerState_lift(_ buf: RustBuffer) throws -> ContainerState {
    return try FfiConverterTypeContainerState.lift(buf)
}

public func FfiConverterTypeContainerState_lower(_ value: ContainerState) -> RustBuffer {
    return FfiConverterTypeContainerState.lower(value)
}


extension ContainerState: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum FocusRegion {
    
    case sidebarSearch
    case sidebarGroup(id: TabGroupId)
    case inTabGroup(tabGroupId: TabGroupId, tabId: TabId)
    case clusterSelection
    case content
}

public struct FfiConverterTypeFocusRegion: FfiConverterRustBuffer {
    typealias SwiftType = FocusRegion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FocusRegion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .sidebarSearch
        
        case 2: return .sidebarGroup(
            id: try FfiConverterTypeTabGroupId.read(from: &buf)
        )
        
        case 3: return .inTabGroup(
            tabGroupId: try FfiConverterTypeTabGroupId.read(from: &buf), 
            tabId: try FfiConverterTypeTabId.read(from: &buf)
        )
        
        case 4: return .clusterSelection
        
        case 5: return .content
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FocusRegion, into buf: inout [UInt8]) {
        switch value {
        
        
        case .sidebarSearch:
            writeInt(&buf, Int32(1))
        
        
        case let .sidebarGroup(id):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTabGroupId.write(id, into: &buf)
            
        
        case let .inTabGroup(tabGroupId,tabId):
            writeInt(&buf, Int32(3))
            FfiConverterTypeTabGroupId.write(tabGroupId, into: &buf)
            FfiConverterTypeTabId.write(tabId, into: &buf)
            
        
        case .clusterSelection:
            writeInt(&buf, Int32(4))
        
        
        case .content:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeFocusRegion_lift(_ buf: RustBuffer) throws -> FocusRegion {
    return try FfiConverterTypeFocusRegion.lift(buf)
}

public func FfiConverterTypeFocusRegion_lower(_ value: FocusRegion) -> RustBuffer {
    return FfiConverterTypeFocusRegion.lower(value)
}


extension FocusRegion: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum GlobalViewModelMessage {
    
    case refreshClusters
    case clustersLoaded(clusters: [ClusterId: Cluster])
    case loadingClient
    case clientLoaded
    case clientLoadError(error: String)
}

public struct FfiConverterTypeGlobalViewModelMessage: FfiConverterRustBuffer {
    typealias SwiftType = GlobalViewModelMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GlobalViewModelMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .refreshClusters
        
        case 2: return .clustersLoaded(
            clusters: try FfiConverterDictionaryTypeClusterIdTypeCluster.read(from: &buf)
        )
        
        case 3: return .loadingClient
        
        case 4: return .clientLoaded
        
        case 5: return .clientLoadError(
            error: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GlobalViewModelMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case .refreshClusters:
            writeInt(&buf, Int32(1))
        
        
        case let .clustersLoaded(clusters):
            writeInt(&buf, Int32(2))
            FfiConverterDictionaryTypeClusterIdTypeCluster.write(clusters, into: &buf)
            
        
        case .loadingClient:
            writeInt(&buf, Int32(3))
        
        
        case .clientLoaded:
            writeInt(&buf, Int32(4))
        
        
        case let .clientLoadError(error):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(error, into: &buf)
            
        }
    }
}


public func FfiConverterTypeGlobalViewModelMessage_lift(_ buf: RustBuffer) throws -> GlobalViewModelMessage {
    return try FfiConverterTypeGlobalViewModelMessage.lift(buf)
}

public func FfiConverterTypeGlobalViewModelMessage_lower(_ value: GlobalViewModelMessage) -> RustBuffer {
    return FfiConverterTypeGlobalViewModelMessage.lower(value)
}


extension GlobalViewModelMessage: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum KeyAwareEvent {
    
    case delete
    case upArrow
    case downArrow
    case leftArrow
    case rightArrow
    case space
    case enter
    case shiftTab
    case tabKey
    case escape
    case optionF
}

public struct FfiConverterTypeKeyAwareEvent: FfiConverterRustBuffer {
    typealias SwiftType = KeyAwareEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyAwareEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .delete
        
        case 2: return .upArrow
        
        case 3: return .downArrow
        
        case 4: return .leftArrow
        
        case 5: return .rightArrow
        
        case 6: return .space
        
        case 7: return .enter
        
        case 8: return .shiftTab
        
        case 9: return .tabKey
        
        case 10: return .escape
        
        case 11: return .optionF
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeyAwareEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case .delete:
            writeInt(&buf, Int32(1))
        
        
        case .upArrow:
            writeInt(&buf, Int32(2))
        
        
        case .downArrow:
            writeInt(&buf, Int32(3))
        
        
        case .leftArrow:
            writeInt(&buf, Int32(4))
        
        
        case .rightArrow:
            writeInt(&buf, Int32(5))
        
        
        case .space:
            writeInt(&buf, Int32(6))
        
        
        case .enter:
            writeInt(&buf, Int32(7))
        
        
        case .shiftTab:
            writeInt(&buf, Int32(8))
        
        
        case .tabKey:
            writeInt(&buf, Int32(9))
        
        
        case .escape:
            writeInt(&buf, Int32(10))
        
        
        case .optionF:
            writeInt(&buf, Int32(11))
        
        }
    }
}


public func FfiConverterTypeKeyAwareEvent_lift(_ buf: RustBuffer) throws -> KeyAwareEvent {
    return try FfiConverterTypeKeyAwareEvent.lift(buf)
}

public func FfiConverterTypeKeyAwareEvent_lower(_ value: KeyAwareEvent) -> RustBuffer {
    return FfiConverterTypeKeyAwareEvent.lower(value)
}


extension KeyAwareEvent: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum MainViewModelField {
    
    case currentFocusRegion(focusRegion: FocusRegion)
    case selectedTab(tabId: TabId)
    case tabGroupExpansions(expansions: [TabGroupId: Bool])
}

public struct FfiConverterTypeMainViewModelField: FfiConverterRustBuffer {
    typealias SwiftType = MainViewModelField

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MainViewModelField {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .currentFocusRegion(
            focusRegion: try FfiConverterTypeFocusRegion.read(from: &buf)
        )
        
        case 2: return .selectedTab(
            tabId: try FfiConverterTypeTabId.read(from: &buf)
        )
        
        case 3: return .tabGroupExpansions(
            expansions: try FfiConverterDictionaryTypeTabGroupIdBool.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MainViewModelField, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .currentFocusRegion(focusRegion):
            writeInt(&buf, Int32(1))
            FfiConverterTypeFocusRegion.write(focusRegion, into: &buf)
            
        
        case let .selectedTab(tabId):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTabId.write(tabId, into: &buf)
            
        
        case let .tabGroupExpansions(expansions):
            writeInt(&buf, Int32(3))
            FfiConverterDictionaryTypeTabGroupIdBool.write(expansions, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMainViewModelField_lift(_ buf: RustBuffer) throws -> MainViewModelField {
    return try FfiConverterTypeMainViewModelField.lift(buf)
}

public func FfiConverterTypeMainViewModelField_lower(_ value: MainViewModelField) -> RustBuffer {
    return FfiConverterTypeMainViewModelField.lower(value)
}


extension MainViewModelField: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum NodeLoadStatus {
    
    case initial
    case loading
    case loaded(nodes: [Node])
    case error(error: String)
}

public struct FfiConverterTypeNodeLoadStatus: FfiConverterRustBuffer {
    typealias SwiftType = NodeLoadStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeLoadStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .initial
        
        case 2: return .loading
        
        case 3: return .loaded(
            nodes: try FfiConverterSequenceTypeNode.read(from: &buf)
        )
        
        case 4: return .error(
            error: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NodeLoadStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .initial:
            writeInt(&buf, Int32(1))
        
        
        case .loading:
            writeInt(&buf, Int32(2))
        
        
        case let .loaded(nodes):
            writeInt(&buf, Int32(3))
            FfiConverterSequenceTypeNode.write(nodes, into: &buf)
            
        
        case let .error(error):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(error, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNodeLoadStatus_lift(_ buf: RustBuffer) throws -> NodeLoadStatus {
    return try FfiConverterTypeNodeLoadStatus.lift(buf)
}

public func FfiConverterTypeNodeLoadStatus_lower(_ value: NodeLoadStatus) -> RustBuffer {
    return FfiConverterTypeNodeLoadStatus.lower(value)
}


extension NodeLoadStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum NodeViewModelMessage {
    
    case loading
    case loaded(nodes: [Node])
    case loadingFailed(error: String)
}

public struct FfiConverterTypeNodeViewModelMessage: FfiConverterRustBuffer {
    typealias SwiftType = NodeViewModelMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NodeViewModelMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .loading
        
        case 2: return .loaded(
            nodes: try FfiConverterSequenceTypeNode.read(from: &buf)
        )
        
        case 3: return .loadingFailed(
            error: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NodeViewModelMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case .loading:
            writeInt(&buf, Int32(1))
        
        
        case let .loaded(nodes):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeNode.write(nodes, into: &buf)
            
        
        case let .loadingFailed(error):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(error, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNodeViewModelMessage_lift(_ buf: RustBuffer) throws -> NodeViewModelMessage {
    return try FfiConverterTypeNodeViewModelMessage.lift(buf)
}

public func FfiConverterTypeNodeViewModelMessage_lower(_ value: NodeViewModelMessage) -> RustBuffer {
    return FfiConverterTypeNodeViewModelMessage.lower(value)
}


extension NodeViewModelMessage: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Phase {
    
    case pending
    case running
    case failed
    case succeeded
    case unknown(rawValue: String)
}

public struct FfiConverterTypePhase: FfiConverterRustBuffer {
    typealias SwiftType = Phase

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Phase {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pending
        
        case 2: return .running
        
        case 3: return .failed
        
        case 4: return .succeeded
        
        case 5: return .unknown(
            rawValue: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Phase, into buf: inout [UInt8]) {
        switch value {
        
        
        case .pending:
            writeInt(&buf, Int32(1))
        
        
        case .running:
            writeInt(&buf, Int32(2))
        
        
        case .failed:
            writeInt(&buf, Int32(3))
        
        
        case .succeeded:
            writeInt(&buf, Int32(4))
        
        
        case let .unknown(rawValue):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(rawValue, into: &buf)
            
        }
    }
}


public func FfiConverterTypePhase_lift(_ buf: RustBuffer) throws -> Phase {
    return try FfiConverterTypePhase.lift(buf)
}

public func FfiConverterTypePhase_lower(_ value: Phase) -> RustBuffer {
    return FfiConverterTypePhase.lower(value)
}


extension Phase: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum PodViewModelMessage {
    
    case loading
    case loaded(pods: [Pod])
    case loadingFailed(error: String)
    case toastWarningMessage(message: String)
    case toastErrorMessage(message: String)
}

public struct FfiConverterTypePodViewModelMessage: FfiConverterRustBuffer {
    typealias SwiftType = PodViewModelMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PodViewModelMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .loading
        
        case 2: return .loaded(
            pods: try FfiConverterSequenceTypePod.read(from: &buf)
        )
        
        case 3: return .loadingFailed(
            error: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .toastWarningMessage(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .toastErrorMessage(
            message: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PodViewModelMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case .loading:
            writeInt(&buf, Int32(1))
        
        
        case let .loaded(pods):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypePod.write(pods, into: &buf)
            
        
        case let .loadingFailed(error):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .toastWarningMessage(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .toastErrorMessage(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


public func FfiConverterTypePodViewModelMessage_lift(_ buf: RustBuffer) throws -> PodViewModelMessage {
    return try FfiConverterTypePodViewModelMessage.lift(buf)
}

public func FfiConverterTypePodViewModelMessage_lower(_ value: PodViewModelMessage) -> RustBuffer {
    return FfiConverterTypePodViewModelMessage.lower(value)
}


extension PodViewModelMessage: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SimpleLoadStatus {
    
    case initial
    case loading
    case loaded
    case error(error: String)
}

public struct FfiConverterTypeSimpleLoadStatus: FfiConverterRustBuffer {
    typealias SwiftType = SimpleLoadStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SimpleLoadStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .initial
        
        case 2: return .loading
        
        case 3: return .loaded
        
        case 4: return .error(
            error: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SimpleLoadStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .initial:
            writeInt(&buf, Int32(1))
        
        
        case .loading:
            writeInt(&buf, Int32(2))
        
        
        case .loaded:
            writeInt(&buf, Int32(3))
        
        
        case let .error(error):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(error, into: &buf)
            
        }
    }
}


public func FfiConverterTypeSimpleLoadStatus_lift(_ buf: RustBuffer) throws -> SimpleLoadStatus {
    return try FfiConverterTypeSimpleLoadStatus.lift(buf)
}

public func FfiConverterTypeSimpleLoadStatus_lower(_ value: SimpleLoadStatus) -> RustBuffer {
    return FfiConverterTypeSimpleLoadStatus.lower(value)
}


extension SimpleLoadStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TabGroupId {
    
    case general
    case workloads
    case config
    case network
    case storage
    case accessControl
    case helm
}

public struct FfiConverterTypeTabGroupId: FfiConverterRustBuffer {
    typealias SwiftType = TabGroupId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TabGroupId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .general
        
        case 2: return .workloads
        
        case 3: return .config
        
        case 4: return .network
        
        case 5: return .storage
        
        case 6: return .accessControl
        
        case 7: return .helm
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TabGroupId, into buf: inout [UInt8]) {
        switch value {
        
        
        case .general:
            writeInt(&buf, Int32(1))
        
        
        case .workloads:
            writeInt(&buf, Int32(2))
        
        
        case .config:
            writeInt(&buf, Int32(3))
        
        
        case .network:
            writeInt(&buf, Int32(4))
        
        
        case .storage:
            writeInt(&buf, Int32(5))
        
        
        case .accessControl:
            writeInt(&buf, Int32(6))
        
        
        case .helm:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeTabGroupId_lift(_ buf: RustBuffer) throws -> TabGroupId {
    return try FfiConverterTypeTabGroupId.lift(buf)
}

public func FfiConverterTypeTabGroupId_lower(_ value: TabGroupId) -> RustBuffer {
    return FfiConverterTypeTabGroupId.lower(value)
}


extension TabGroupId: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TabId {
    
    case clusterTab
    case nodes
    case nameSpaces
    case events
    case overview
    case pods
    case deployments
    case daemonSets
    case statefulSets
    case replicaSets
    case jobs
    case cronJobs
    case configMaps
    case secrets
    case resourceQuotas
    case limitRanges
    case horizontalPodAutoscalers
    case podDisruptionBudgets
    case priorityClasses
    case runtimeClasses
    case leases
    case services
    case endpoints
    case ingresses
    case networkPolicies
    case portForwarding
    case persistentVolumeClaims
    case persistentVolumes
    case storageClasses
    case serviceAccounts
    case clusterRoles
    case roles
    case clusterRoleBindings
    case roleBindings
    case podSecurityPolicies
    case charts
    case releases
}

public struct FfiConverterTypeTabId: FfiConverterRustBuffer {
    typealias SwiftType = TabId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TabId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .clusterTab
        
        case 2: return .nodes
        
        case 3: return .nameSpaces
        
        case 4: return .events
        
        case 5: return .overview
        
        case 6: return .pods
        
        case 7: return .deployments
        
        case 8: return .daemonSets
        
        case 9: return .statefulSets
        
        case 10: return .replicaSets
        
        case 11: return .jobs
        
        case 12: return .cronJobs
        
        case 13: return .configMaps
        
        case 14: return .secrets
        
        case 15: return .resourceQuotas
        
        case 16: return .limitRanges
        
        case 17: return .horizontalPodAutoscalers
        
        case 18: return .podDisruptionBudgets
        
        case 19: return .priorityClasses
        
        case 20: return .runtimeClasses
        
        case 21: return .leases
        
        case 22: return .services
        
        case 23: return .endpoints
        
        case 24: return .ingresses
        
        case 25: return .networkPolicies
        
        case 26: return .portForwarding
        
        case 27: return .persistentVolumeClaims
        
        case 28: return .persistentVolumes
        
        case 29: return .storageClasses
        
        case 30: return .serviceAccounts
        
        case 31: return .clusterRoles
        
        case 32: return .roles
        
        case 33: return .clusterRoleBindings
        
        case 34: return .roleBindings
        
        case 35: return .podSecurityPolicies
        
        case 36: return .charts
        
        case 37: return .releases
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TabId, into buf: inout [UInt8]) {
        switch value {
        
        
        case .clusterTab:
            writeInt(&buf, Int32(1))
        
        
        case .nodes:
            writeInt(&buf, Int32(2))
        
        
        case .nameSpaces:
            writeInt(&buf, Int32(3))
        
        
        case .events:
            writeInt(&buf, Int32(4))
        
        
        case .overview:
            writeInt(&buf, Int32(5))
        
        
        case .pods:
            writeInt(&buf, Int32(6))
        
        
        case .deployments:
            writeInt(&buf, Int32(7))
        
        
        case .daemonSets:
            writeInt(&buf, Int32(8))
        
        
        case .statefulSets:
            writeInt(&buf, Int32(9))
        
        
        case .replicaSets:
            writeInt(&buf, Int32(10))
        
        
        case .jobs:
            writeInt(&buf, Int32(11))
        
        
        case .cronJobs:
            writeInt(&buf, Int32(12))
        
        
        case .configMaps:
            writeInt(&buf, Int32(13))
        
        
        case .secrets:
            writeInt(&buf, Int32(14))
        
        
        case .resourceQuotas:
            writeInt(&buf, Int32(15))
        
        
        case .limitRanges:
            writeInt(&buf, Int32(16))
        
        
        case .horizontalPodAutoscalers:
            writeInt(&buf, Int32(17))
        
        
        case .podDisruptionBudgets:
            writeInt(&buf, Int32(18))
        
        
        case .priorityClasses:
            writeInt(&buf, Int32(19))
        
        
        case .runtimeClasses:
            writeInt(&buf, Int32(20))
        
        
        case .leases:
            writeInt(&buf, Int32(21))
        
        
        case .services:
            writeInt(&buf, Int32(22))
        
        
        case .endpoints:
            writeInt(&buf, Int32(23))
        
        
        case .ingresses:
            writeInt(&buf, Int32(24))
        
        
        case .networkPolicies:
            writeInt(&buf, Int32(25))
        
        
        case .portForwarding:
            writeInt(&buf, Int32(26))
        
        
        case .persistentVolumeClaims:
            writeInt(&buf, Int32(27))
        
        
        case .persistentVolumes:
            writeInt(&buf, Int32(28))
        
        
        case .storageClasses:
            writeInt(&buf, Int32(29))
        
        
        case .serviceAccounts:
            writeInt(&buf, Int32(30))
        
        
        case .clusterRoles:
            writeInt(&buf, Int32(31))
        
        
        case .roles:
            writeInt(&buf, Int32(32))
        
        
        case .clusterRoleBindings:
            writeInt(&buf, Int32(33))
        
        
        case .roleBindings:
            writeInt(&buf, Int32(34))
        
        
        case .podSecurityPolicies:
            writeInt(&buf, Int32(35))
        
        
        case .charts:
            writeInt(&buf, Int32(36))
        
        
        case .releases:
            writeInt(&buf, Int32(37))
        
        }
    }
}


public func FfiConverterTypeTabId_lift(_ buf: RustBuffer) throws -> TabId {
    return try FfiConverterTypeTabId.lift(buf)
}

public func FfiConverterTypeTabId_lower(_ value: TabId) -> RustBuffer {
    return FfiConverterTypeTabId.lower(value)
}


extension TabId: Equatable, Hashable {}



fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias UniFFICallbackHandle = UInt64
fileprivate class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Declaration and FfiConverters for GlobalViewModelCallback Callback Interface

public protocol GlobalViewModelCallback : AnyObject {
    func callback(message: GlobalViewModelMessage) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceGlobalViewModelCallback : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeCallback(_ swiftCallbackInterface: GlobalViewModelCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.callback(
                    message:  try FfiConverterTypeGlobalViewModelMessage.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceGlobalViewModelCallback.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: GlobalViewModelCallback
            do {
                cb = try FfiConverterCallbackInterfaceGlobalViewModelCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("GlobalViewModelCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeCallback(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceGlobalViewModelCallback {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_kube_viewer_fn_init_callback_globalviewmodelcallback(foreignCallbackCallbackInterfaceGlobalViewModelCallback, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<GlobalViewModelCallback>()
}

extension FfiConverterCallbackInterfaceGlobalViewModelCallback : FfiConverter {
    typealias SwiftType = GlobalViewModelCallback
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for MainViewModelUpdater Callback Interface

public protocol MainViewModelUpdater : AnyObject {
    func update(field: MainViewModelField) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceMainViewModelUpdater : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeUpdate(_ swiftCallbackInterface: MainViewModelUpdater, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.update(
                    field:  try FfiConverterTypeMainViewModelField.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceMainViewModelUpdater.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: MainViewModelUpdater
            do {
                cb = try FfiConverterCallbackInterfaceMainViewModelUpdater.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("MainViewModelUpdater: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeUpdate(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceMainViewModelUpdater {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_kube_viewer_fn_init_callback_mainviewmodelupdater(foreignCallbackCallbackInterfaceMainViewModelUpdater, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<MainViewModelUpdater>()
}

extension FfiConverterCallbackInterfaceMainViewModelUpdater : FfiConverter {
    typealias SwiftType = MainViewModelUpdater
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for NodeViewModelCallback Callback Interface

public protocol NodeViewModelCallback : AnyObject {
    func callback(message: NodeViewModelMessage) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceNodeViewModelCallback : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeCallback(_ swiftCallbackInterface: NodeViewModelCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.callback(
                    message:  try FfiConverterTypeNodeViewModelMessage.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceNodeViewModelCallback.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: NodeViewModelCallback
            do {
                cb = try FfiConverterCallbackInterfaceNodeViewModelCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("NodeViewModelCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeCallback(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceNodeViewModelCallback {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_kube_viewer_fn_init_callback_nodeviewmodelcallback(foreignCallbackCallbackInterfaceNodeViewModelCallback, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<NodeViewModelCallback>()
}

extension FfiConverterCallbackInterfaceNodeViewModelCallback : FfiConverter {
    typealias SwiftType = NodeViewModelCallback
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for PodViewModelCallback Callback Interface

public protocol PodViewModelCallback : AnyObject {
    func callback(message: PodViewModelMessage) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfacePodViewModelCallback : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeCallback(_ swiftCallbackInterface: PodViewModelCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.callback(
                    message:  try FfiConverterTypePodViewModelMessage.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfacePodViewModelCallback.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: PodViewModelCallback
            do {
                cb = try FfiConverterCallbackInterfacePodViewModelCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("PodViewModelCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeCallback(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfacePodViewModelCallback {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_kube_viewer_fn_init_callback_podviewmodelcallback(foreignCallbackCallbackInterfacePodViewModelCallback, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<PodViewModelCallback>()
}

extension FfiConverterCallbackInterfacePodViewModelCallback : FfiConverter {
    typealias SwiftType = PodViewModelCallback
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionInt32: FfiConverterRustBuffer {
    typealias SwiftType = Int32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeCluster: FfiConverterRustBuffer {
    typealias SwiftType = Cluster?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCluster.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCluster.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeContainerState: FfiConverterRustBuffer {
    typealias SwiftType = ContainerState?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeContainerState.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeContainerState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt32: FfiConverterRustBuffer {
    typealias SwiftType = [UInt32]

    public static func write(_ value: [UInt32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt32.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeContainer: FfiConverterRustBuffer {
    typealias SwiftType = [Container]

    public static func write(_ value: [Container], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeContainer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Container] {
        let len: Int32 = try readInt(&buf)
        var seq = [Container]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeContainer.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeNode: FfiConverterRustBuffer {
    typealias SwiftType = [Node]

    public static func write(_ value: [Node], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNode.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Node] {
        let len: Int32 = try readInt(&buf)
        var seq = [Node]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNode.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeNodeAddress: FfiConverterRustBuffer {
    typealias SwiftType = [NodeAddress]

    public static func write(_ value: [NodeAddress], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNodeAddress.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NodeAddress] {
        let len: Int32 = try readInt(&buf)
        var seq = [NodeAddress]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNodeAddress.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeNodeCondition: FfiConverterRustBuffer {
    typealias SwiftType = [NodeCondition]

    public static func write(_ value: [NodeCondition], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNodeCondition.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NodeCondition] {
        let len: Int32 = try readInt(&buf)
        var seq = [NodeCondition]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNodeCondition.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeOwnerReference: FfiConverterRustBuffer {
    typealias SwiftType = [OwnerReference]

    public static func write(_ value: [OwnerReference], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeOwnerReference.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [OwnerReference] {
        let len: Int32 = try readInt(&buf)
        var seq = [OwnerReference]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOwnerReference.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePod: FfiConverterRustBuffer {
    typealias SwiftType = [Pod]

    public static func write(_ value: [Pod], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePod.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Pod] {
        let len: Int32 = try readInt(&buf)
        var seq = [Pod]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePod.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePodCondition: FfiConverterRustBuffer {
    typealias SwiftType = [PodCondition]

    public static func write(_ value: [PodCondition], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePodCondition.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PodCondition] {
        let len: Int32 = try readInt(&buf)
        var seq = [PodCondition]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePodCondition.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTab: FfiConverterRustBuffer {
    typealias SwiftType = [Tab]

    public static func write(_ value: [Tab], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTab.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Tab] {
        let len: Int32 = try readInt(&buf)
        var seq = [Tab]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTab.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTabGroup: FfiConverterRustBuffer {
    typealias SwiftType = [TabGroup]

    public static func write(_ value: [TabGroup], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTabGroup.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TabGroup] {
        let len: Int32 = try readInt(&buf)
        var seq = [TabGroup]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTabGroup.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTaint: FfiConverterRustBuffer {
    typealias SwiftType = [Taint]

    public static func write(_ value: [Taint], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTaint.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Taint] {
        let len: Int32 = try readInt(&buf)
        var seq = [Taint]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTaint.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeToleration: FfiConverterRustBuffer {
    typealias SwiftType = [Toleration]

    public static func write(_ value: [Toleration], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeToleration.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Toleration] {
        let len: Int32 = try readInt(&buf)
        var seq = [Toleration]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeToleration.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePodId: FfiConverterRustBuffer {
    typealias SwiftType = [PodId]

    public static func write(_ value: [PodId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePodId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PodId] {
        let len: Int32 = try readInt(&buf)
        var seq = [PodId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePodId.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypeClusterIdTypeCluster: FfiConverterRustBuffer {
    public static func write(_ value: [ClusterId: Cluster], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeClusterId.write(key, into: &buf)
            FfiConverterTypeCluster.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ClusterId: Cluster] {
        let len: Int32 = try readInt(&buf)
        var dict = [ClusterId: Cluster]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeClusterId.read(from: &buf)
            let value = try FfiConverterTypeCluster.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypeTabGroupIdBool: FfiConverterRustBuffer {
    public static func write(_ value: [TabGroupId: Bool], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeTabGroupId.write(key, into: &buf)
            FfiConverterBool.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TabGroupId: Bool] {
        let len: Int32 = try readInt(&buf)
        var dict = [TabGroupId: Bool]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeTabGroupId.read(from: &buf)
            let value = try FfiConverterBool.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypeTabIdTypeTab: FfiConverterRustBuffer {
    public static func write(_ value: [TabId: Tab], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeTabId.write(key, into: &buf)
            FfiConverterTypeTab.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TabId: Tab] {
        let len: Int32 = try readInt(&buf)
        var dict = [TabId: Tab]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeTabId.read(from: &buf)
            let value = try FfiConverterTypeTab.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias ContainerId = String
public struct FfiConverterTypeContainerId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ContainerId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: ContainerId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> ContainerId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: ContainerId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeContainerId_lift(_ value: RustBuffer) throws -> ContainerId {
    return try FfiConverterTypeContainerId.lift(value)
}

public func FfiConverterTypeContainerId_lower(_ value: ContainerId) -> RustBuffer {
    return FfiConverterTypeContainerId.lower(value)
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias PodId = String
public struct FfiConverterTypePodId: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PodId {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: PodId, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> PodId {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: PodId) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypePodId_lift(_ value: RustBuffer) throws -> PodId {
    return try FfiConverterTypePodId.lift(value)
}

public func FfiConverterTypePodId_lower(_ value: PodId) -> RustBuffer {
    return FfiConverterTypePodId.lower(value)
}// Callbacks for async functions

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureCallbackHandlerVoid(
    rawContinutation: UnsafeRawPointer,
    returnValue: UInt8,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<(), Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: ())
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerUInt64(
    rawContinutation: UnsafeRawPointer,
    returnValue: UInt64,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<UInt64, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterUInt64.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerBool(
    rawContinutation: UnsafeRawPointer,
    returnValue: Int8,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<Bool, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterBool.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerString(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<String, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterString.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeFocusRegionHasher(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<FocusRegionHasher, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeFocusRegionHasher.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeRustGlobalViewModel(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<RustGlobalViewModel, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeRustGlobalViewModel.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeRustMainViewModel(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<RustMainViewModel, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeRustMainViewModel.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeRustNodeViewModel(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<RustNodeViewModel, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeRustNodeViewModel.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeRustPodViewModel(
    rawContinutation: UnsafeRawPointer,
    returnValue: UnsafeMutableRawPointer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<RustPodViewModel, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeRustPodViewModel.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeContainer(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<Container, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeContainer.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeNode(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<Node, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeNode.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypePod(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<Pod, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypePod.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeContainerState(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<ContainerState, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeContainerState.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeFocusRegion(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<FocusRegion, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeFocusRegion.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerTypeTabId(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<TabId, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterTypeTabId.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionString(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<String?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterOptionString.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerOptionTypeCluster(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<Cluster?, Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterOptionTypeCluster.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerSequenceTypeNode(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<[Node], Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterSequenceTypeNode.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerSequenceTypePod(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<[Pod], Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterSequenceTypePod.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerSequenceTypeTab(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<[Tab], Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterSequenceTypeTab.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerSequenceTypeTabGroup(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<[TabGroup], Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterSequenceTypeTabGroup.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerDictionaryTypeClusterIdTypeCluster(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<[ClusterId: Cluster], Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterDictionaryTypeClusterIdTypeCluster.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerDictionaryTypeTabGroupIdBool(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<[TabGroupId: Bool], Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterDictionaryTypeTabGroupIdBool.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}
fileprivate func uniffiFutureCallbackHandlerDictionaryTypeTabIdTypeTab(
    rawContinutation: UnsafeRawPointer,
    returnValue: RustBuffer,
    callStatus: RustCallStatus) {

    let continuation = rawContinutation.bindMemory(
        to: CheckedContinuation<[TabId: Tab], Error>.self,
        capacity: 1
    )

    do {
        try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: nil)
        continuation.pointee.resume(returning: try FfiConverterDictionaryTypeTabIdTypeTab.lift(returnValue))
    } catch let error {
        continuation.pointee.resume(throwing: error)
    }
}

public func containerPreview()  -> Container {
    return try!  FfiConverterTypeContainer.lift(
        try! rustCall() {
    uniffi_kube_viewer_fn_func_container_preview($0)
}
    )
}

public func containersPreview()  -> Container {
    return try!  FfiConverterTypeContainer.lift(
        try! rustCall() {
    uniffi_kube_viewer_fn_func_containers_preview($0)
}
    )
}

public func nodePreview()  -> Node {
    return try!  FfiConverterTypeNode.lift(
        try! rustCall() {
    uniffi_kube_viewer_fn_func_node_preview($0)
}
    )
}

public func podContainerStateRunning()  -> ContainerState {
    return try!  FfiConverterTypeContainerState.lift(
        try! rustCall() {
    uniffi_kube_viewer_fn_func_pod_container_state_running($0)
}
    )
}

public func podContainerStateTerminated()  -> ContainerState {
    return try!  FfiConverterTypeContainerState.lift(
        try! rustCall() {
    uniffi_kube_viewer_fn_func_pod_container_state_terminated($0)
}
    )
}

public func podContainerStateWaiting()  -> ContainerState {
    return try!  FfiConverterTypeContainerState.lift(
        try! rustCall() {
    uniffi_kube_viewer_fn_func_pod_container_state_waiting($0)
}
    )
}

public func podExecCmd(namespace: String, podId: String)  -> String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_kube_viewer_fn_func_pod_exec_cmd(
        FfiConverterString.lower(namespace),
        FfiConverterString.lower(podId),$0)
}
    )
}

public func podLogCmd(namespace: String, podId: String)  -> String {
    return try!  FfiConverterString.lift(
        try! rustCall() {
    uniffi_kube_viewer_fn_func_pod_log_cmd(
        FfiConverterString.lower(namespace),
        FfiConverterString.lower(podId),$0)
}
    )
}

public func podPreview()  -> Pod {
    return try!  FfiConverterTypePod.lift(
        try! rustCall() {
    uniffi_kube_viewer_fn_func_pod_preview($0)
}
    )
}

public func unixToUtcString(unix: Int64)  -> String? {
    return try!  FfiConverterOptionString.lift(
        try! rustCall() {
    uniffi_kube_viewer_fn_func_unix_to_utc_string(
        FfiConverterInt64.lower(unix),$0)
}
    )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 23
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_kube_viewer_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_kube_viewer_checksum_func_container_preview() != 7093) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_func_containers_preview() != 58238) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_func_node_preview() != 63126) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_func_pod_container_state_running() != 20914) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_func_pod_container_state_terminated() != 30541) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_func_pod_container_state_waiting() != 8164) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_func_pod_exec_cmd() != 38122) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_func_pod_log_cmd() != 16844) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_func_pod_preview() != 22666) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_func_unix_to_utc_string() != 6226) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_focusregionhasher_hash() != 26261) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustnodeviewmodel_add_callback_listener() != 18310) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustnodeviewmodel_fetch_nodes() != 58925) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustnodeviewmodel_nodes() != 38863) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustnodeviewmodel_stop_watcher() != 42163) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustglobalviewmodel_add_callback_listener() != 33763) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustglobalviewmodel_clusters() != 2845) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustglobalviewmodel_load_client() != 24253) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustmainviewmodel_add_update_listener() != 49177) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustmainviewmodel_async_do() != 59783) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustmainviewmodel_current_focus_region() != 22196) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustmainviewmodel_handle_key_input() != 28228) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustmainviewmodel_select_first_filtered_tab() != 11835) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustmainviewmodel_selected_cluster() != 10174) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustmainviewmodel_selected_tab() != 10584) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustmainviewmodel_set_current_focus_region() != 26495) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustmainviewmodel_set_selected_cluster() != 34172) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustmainviewmodel_set_selected_tab() != 27353) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustmainviewmodel_set_tab_group_expansions() != 58831) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustmainviewmodel_set_window_closed() != 5586) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustmainviewmodel_tab_group_expansions() != 4820) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustmainviewmodel_tab_groups_filtered() != 7306) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustmainviewmodel_tabs() != 23974) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustmainviewmodel_tabs_map() != 2970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustpodviewmodel_delete_pod() != 1122) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustpodviewmodel_delete_pods() != 6817) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustpodviewmodel_fetch_pods() != 57451) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustpodviewmodel_initialize_model_with_responder() != 30407) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustpodviewmodel_pods() != 56851) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustpodviewmodel_start_watcher() != 22929) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_rustpodviewmodel_stop_watcher() != 18778) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_constructor_focusregionhasher_new() != 32388) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_constructor_rustnodeviewmodel_new() != 35854) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_constructor_rustnodeviewmodel_preview() != 15716) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_constructor_rustglobalviewmodel_new() != 2525) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_constructor_rustmainviewmodel_new() != 52692) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_constructor_rustpodviewmodel_new() != 28314) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_constructor_rustpodviewmodel_preview() != 64189) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_globalviewmodelcallback_callback() != 30455) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_mainviewmodelupdater_update() != 41841) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_nodeviewmodelcallback_callback() != 48251) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_kube_viewer_checksum_method_podviewmodelcallback_callback() != 8953) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiInitForeignExecutor()
    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}